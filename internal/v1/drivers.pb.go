// Copyright 2020 StrongDM Inc
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by protoc-gen-go. DO NOT EDIT.
// source: drivers.proto

package v1

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	_ "github.com/grpc-ecosystem/grpc-gateway/protoc-gen-swagger/options"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// A Resource is a server or service which clients connect to through relays.
type Resource struct {
	// Types that are valid to be assigned to Resource:
	//	*Resource_Athena
	//	*Resource_BigQuery
	//	*Resource_Cassandra
	//	*Resource_Druid
	//	*Resource_DynamoDb
	//	*Resource_AmazonEs
	//	*Resource_Elastic
	//	*Resource_HttpBasicAuth
	//	*Resource_HttpNoAuth
	//	*Resource_HttpAuth
	//	*Resource_Kubernetes
	//	*Resource_KubernetesBasicAuth
	//	*Resource_KubernetesServiceAccount
	//	*Resource_AmazonEks
	//	*Resource_GoogleGke
	//	*Resource_Aks
	//	*Resource_AksBasicAuth
	//	*Resource_AksServiceAccount
	//	*Resource_Memcached
	//	*Resource_MongoLegacyHost
	//	*Resource_MongoLegacyReplicaset
	//	*Resource_MongoHost
	//	*Resource_MongoReplicaSet
	//	*Resource_Mysql
	//	*Resource_AuroraMysql
	//	*Resource_Clustrix
	//	*Resource_Maria
	//	*Resource_Memsql
	//	*Resource_Oracle
	//	*Resource_Postgres
	//	*Resource_AuroraPostgres
	//	*Resource_Greenplum
	//	*Resource_Cockroach
	//	*Resource_Redshift
	//	*Resource_Presto
	//	*Resource_Rdp
	//	*Resource_Redis
	//	*Resource_ElasticacheRedis
	//	*Resource_Snowflake
	//	*Resource_SqlServer
	//	*Resource_Ssh
	//	*Resource_Sybase
	//	*Resource_SybaseIq
	//	*Resource_Teradata
	Resource             isResource_Resource `protobuf_oneof:"resource"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *Resource) Reset()         { *m = Resource{} }
func (m *Resource) String() string { return proto.CompactTextString(m) }
func (*Resource) ProtoMessage()    {}
func (*Resource) Descriptor() ([]byte, []int) {
	return fileDescriptor_81dfd49b5b303fb4, []int{0}
}

func (m *Resource) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Resource.Unmarshal(m, b)
}
func (m *Resource) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Resource.Marshal(b, m, deterministic)
}
func (m *Resource) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Resource.Merge(m, src)
}
func (m *Resource) XXX_Size() int {
	return xxx_messageInfo_Resource.Size(m)
}
func (m *Resource) XXX_DiscardUnknown() {
	xxx_messageInfo_Resource.DiscardUnknown(m)
}

var xxx_messageInfo_Resource proto.InternalMessageInfo

type isResource_Resource interface {
	isResource_Resource()
}

type Resource_Athena struct {
	Athena *Athena `protobuf:"bytes,100,opt,name=athena,proto3,oneof"`
}

type Resource_BigQuery struct {
	BigQuery *BigQuery `protobuf:"bytes,200,opt,name=big_query,json=bigQuery,proto3,oneof"`
}

type Resource_Cassandra struct {
	Cassandra *Cassandra `protobuf:"bytes,300,opt,name=cassandra,proto3,oneof"`
}

type Resource_Druid struct {
	Druid *Druid `protobuf:"bytes,400,opt,name=druid,proto3,oneof"`
}

type Resource_DynamoDb struct {
	DynamoDb *DynamoDB `protobuf:"bytes,500,opt,name=dynamo_db,json=dynamoDb,proto3,oneof"`
}

type Resource_AmazonEs struct {
	AmazonEs *AmazonES `protobuf:"bytes,600,opt,name=amazon_es,json=amazonEs,proto3,oneof"`
}

type Resource_Elastic struct {
	Elastic *Elastic `protobuf:"bytes,601,opt,name=elastic,proto3,oneof"`
}

type Resource_HttpBasicAuth struct {
	HttpBasicAuth *HTTPBasicAuth `protobuf:"bytes,700,opt,name=http_basic_auth,json=httpBasicAuth,proto3,oneof"`
}

type Resource_HttpNoAuth struct {
	HttpNoAuth *HTTPNoAuth `protobuf:"bytes,701,opt,name=http_no_auth,json=httpNoAuth,proto3,oneof"`
}

type Resource_HttpAuth struct {
	HttpAuth *HTTPAuth `protobuf:"bytes,702,opt,name=http_auth,json=httpAuth,proto3,oneof"`
}

type Resource_Kubernetes struct {
	Kubernetes *Kubernetes `protobuf:"bytes,800,opt,name=kubernetes,proto3,oneof"`
}

type Resource_KubernetesBasicAuth struct {
	KubernetesBasicAuth *KubernetesBasicAuth `protobuf:"bytes,801,opt,name=kubernetes_basic_auth,json=kubernetesBasicAuth,proto3,oneof"`
}

type Resource_KubernetesServiceAccount struct {
	KubernetesServiceAccount *KubernetesServiceAccount `protobuf:"bytes,804,opt,name=kubernetes_service_account,json=kubernetesServiceAccount,proto3,oneof"`
}

type Resource_AmazonEks struct {
	AmazonEks *AmazonEKS `protobuf:"bytes,802,opt,name=amazon_eks,json=amazonEks,proto3,oneof"`
}

type Resource_GoogleGke struct {
	GoogleGke *GoogleGKE `protobuf:"bytes,803,opt,name=google_gke,json=googleGke,proto3,oneof"`
}

type Resource_Aks struct {
	Aks *AKS `protobuf:"bytes,805,opt,name=aks,proto3,oneof"`
}

type Resource_AksBasicAuth struct {
	AksBasicAuth *AKSBasicAuth `protobuf:"bytes,806,opt,name=aks_basic_auth,json=aksBasicAuth,proto3,oneof"`
}

type Resource_AksServiceAccount struct {
	AksServiceAccount *AKSServiceAccount `protobuf:"bytes,807,opt,name=aks_service_account,json=aksServiceAccount,proto3,oneof"`
}

type Resource_Memcached struct {
	Memcached *Memcached `protobuf:"bytes,900,opt,name=memcached,proto3,oneof"`
}

type Resource_MongoLegacyHost struct {
	MongoLegacyHost *MongoLegacyHost `protobuf:"bytes,1000,opt,name=mongo_legacy_host,json=mongoLegacyHost,proto3,oneof"`
}

type Resource_MongoLegacyReplicaset struct {
	MongoLegacyReplicaset *MongoLegacyReplicaset `protobuf:"bytes,1001,opt,name=mongo_legacy_replicaset,json=mongoLegacyReplicaset,proto3,oneof"`
}

type Resource_MongoHost struct {
	MongoHost *MongoHost `protobuf:"bytes,1002,opt,name=mongo_host,json=mongoHost,proto3,oneof"`
}

type Resource_MongoReplicaSet struct {
	MongoReplicaSet *MongoReplicaSet `protobuf:"bytes,1003,opt,name=mongo_replica_set,json=mongoReplicaSet,proto3,oneof"`
}

type Resource_Mysql struct {
	Mysql *Mysql `protobuf:"bytes,1100,opt,name=mysql,proto3,oneof"`
}

type Resource_AuroraMysql struct {
	AuroraMysql *AuroraMysql `protobuf:"bytes,1101,opt,name=aurora_mysql,json=auroraMysql,proto3,oneof"`
}

type Resource_Clustrix struct {
	Clustrix *Clustrix `protobuf:"bytes,1102,opt,name=clustrix,proto3,oneof"`
}

type Resource_Maria struct {
	Maria *Maria `protobuf:"bytes,1103,opt,name=maria,proto3,oneof"`
}

type Resource_Memsql struct {
	Memsql *Memsql `protobuf:"bytes,1104,opt,name=memsql,proto3,oneof"`
}

type Resource_Oracle struct {
	Oracle *Oracle `protobuf:"bytes,1200,opt,name=oracle,proto3,oneof"`
}

type Resource_Postgres struct {
	Postgres *Postgres `protobuf:"bytes,1300,opt,name=postgres,proto3,oneof"`
}

type Resource_AuroraPostgres struct {
	AuroraPostgres *AuroraPostgres `protobuf:"bytes,1301,opt,name=aurora_postgres,json=auroraPostgres,proto3,oneof"`
}

type Resource_Greenplum struct {
	Greenplum *Greenplum `protobuf:"bytes,1302,opt,name=greenplum,proto3,oneof"`
}

type Resource_Cockroach struct {
	Cockroach *Cockroach `protobuf:"bytes,1303,opt,name=cockroach,proto3,oneof"`
}

type Resource_Redshift struct {
	Redshift *Redshift `protobuf:"bytes,1304,opt,name=redshift,proto3,oneof"`
}

type Resource_Presto struct {
	Presto *Presto `protobuf:"bytes,1400,opt,name=presto,proto3,oneof"`
}

type Resource_Rdp struct {
	Rdp *RDP `protobuf:"bytes,1500,opt,name=rdp,proto3,oneof"`
}

type Resource_Redis struct {
	Redis *Redis `protobuf:"bytes,1600,opt,name=redis,proto3,oneof"`
}

type Resource_ElasticacheRedis struct {
	ElasticacheRedis *ElasticacheRedis `protobuf:"bytes,1601,opt,name=elasticache_redis,json=elasticacheRedis,proto3,oneof"`
}

type Resource_Snowflake struct {
	Snowflake *Snowflake `protobuf:"bytes,1700,opt,name=snowflake,proto3,oneof"`
}

type Resource_SqlServer struct {
	SqlServer *SQLServer `protobuf:"bytes,1800,opt,name=sql_server,json=sqlServer,proto3,oneof"`
}

type Resource_Ssh struct {
	Ssh *SSH `protobuf:"bytes,1900,opt,name=ssh,proto3,oneof"`
}

type Resource_Sybase struct {
	Sybase *Sybase `protobuf:"bytes,2000,opt,name=sybase,proto3,oneof"`
}

type Resource_SybaseIq struct {
	SybaseIq *SybaseIQ `protobuf:"bytes,2001,opt,name=sybase_iq,json=sybaseIq,proto3,oneof"`
}

type Resource_Teradata struct {
	Teradata *Teradata `protobuf:"bytes,2100,opt,name=teradata,proto3,oneof"`
}

func (*Resource_Athena) isResource_Resource() {}

func (*Resource_BigQuery) isResource_Resource() {}

func (*Resource_Cassandra) isResource_Resource() {}

func (*Resource_Druid) isResource_Resource() {}

func (*Resource_DynamoDb) isResource_Resource() {}

func (*Resource_AmazonEs) isResource_Resource() {}

func (*Resource_Elastic) isResource_Resource() {}

func (*Resource_HttpBasicAuth) isResource_Resource() {}

func (*Resource_HttpNoAuth) isResource_Resource() {}

func (*Resource_HttpAuth) isResource_Resource() {}

func (*Resource_Kubernetes) isResource_Resource() {}

func (*Resource_KubernetesBasicAuth) isResource_Resource() {}

func (*Resource_KubernetesServiceAccount) isResource_Resource() {}

func (*Resource_AmazonEks) isResource_Resource() {}

func (*Resource_GoogleGke) isResource_Resource() {}

func (*Resource_Aks) isResource_Resource() {}

func (*Resource_AksBasicAuth) isResource_Resource() {}

func (*Resource_AksServiceAccount) isResource_Resource() {}

func (*Resource_Memcached) isResource_Resource() {}

func (*Resource_MongoLegacyHost) isResource_Resource() {}

func (*Resource_MongoLegacyReplicaset) isResource_Resource() {}

func (*Resource_MongoHost) isResource_Resource() {}

func (*Resource_MongoReplicaSet) isResource_Resource() {}

func (*Resource_Mysql) isResource_Resource() {}

func (*Resource_AuroraMysql) isResource_Resource() {}

func (*Resource_Clustrix) isResource_Resource() {}

func (*Resource_Maria) isResource_Resource() {}

func (*Resource_Memsql) isResource_Resource() {}

func (*Resource_Oracle) isResource_Resource() {}

func (*Resource_Postgres) isResource_Resource() {}

func (*Resource_AuroraPostgres) isResource_Resource() {}

func (*Resource_Greenplum) isResource_Resource() {}

func (*Resource_Cockroach) isResource_Resource() {}

func (*Resource_Redshift) isResource_Resource() {}

func (*Resource_Presto) isResource_Resource() {}

func (*Resource_Rdp) isResource_Resource() {}

func (*Resource_Redis) isResource_Resource() {}

func (*Resource_ElasticacheRedis) isResource_Resource() {}

func (*Resource_Snowflake) isResource_Resource() {}

func (*Resource_SqlServer) isResource_Resource() {}

func (*Resource_Ssh) isResource_Resource() {}

func (*Resource_Sybase) isResource_Resource() {}

func (*Resource_SybaseIq) isResource_Resource() {}

func (*Resource_Teradata) isResource_Resource() {}

func (m *Resource) GetResource() isResource_Resource {
	if m != nil {
		return m.Resource
	}
	return nil
}

func (m *Resource) GetAthena() *Athena {
	if x, ok := m.GetResource().(*Resource_Athena); ok {
		return x.Athena
	}
	return nil
}

func (m *Resource) GetBigQuery() *BigQuery {
	if x, ok := m.GetResource().(*Resource_BigQuery); ok {
		return x.BigQuery
	}
	return nil
}

func (m *Resource) GetCassandra() *Cassandra {
	if x, ok := m.GetResource().(*Resource_Cassandra); ok {
		return x.Cassandra
	}
	return nil
}

func (m *Resource) GetDruid() *Druid {
	if x, ok := m.GetResource().(*Resource_Druid); ok {
		return x.Druid
	}
	return nil
}

func (m *Resource) GetDynamoDb() *DynamoDB {
	if x, ok := m.GetResource().(*Resource_DynamoDb); ok {
		return x.DynamoDb
	}
	return nil
}

func (m *Resource) GetAmazonEs() *AmazonES {
	if x, ok := m.GetResource().(*Resource_AmazonEs); ok {
		return x.AmazonEs
	}
	return nil
}

func (m *Resource) GetElastic() *Elastic {
	if x, ok := m.GetResource().(*Resource_Elastic); ok {
		return x.Elastic
	}
	return nil
}

func (m *Resource) GetHttpBasicAuth() *HTTPBasicAuth {
	if x, ok := m.GetResource().(*Resource_HttpBasicAuth); ok {
		return x.HttpBasicAuth
	}
	return nil
}

func (m *Resource) GetHttpNoAuth() *HTTPNoAuth {
	if x, ok := m.GetResource().(*Resource_HttpNoAuth); ok {
		return x.HttpNoAuth
	}
	return nil
}

func (m *Resource) GetHttpAuth() *HTTPAuth {
	if x, ok := m.GetResource().(*Resource_HttpAuth); ok {
		return x.HttpAuth
	}
	return nil
}

func (m *Resource) GetKubernetes() *Kubernetes {
	if x, ok := m.GetResource().(*Resource_Kubernetes); ok {
		return x.Kubernetes
	}
	return nil
}

func (m *Resource) GetKubernetesBasicAuth() *KubernetesBasicAuth {
	if x, ok := m.GetResource().(*Resource_KubernetesBasicAuth); ok {
		return x.KubernetesBasicAuth
	}
	return nil
}

func (m *Resource) GetKubernetesServiceAccount() *KubernetesServiceAccount {
	if x, ok := m.GetResource().(*Resource_KubernetesServiceAccount); ok {
		return x.KubernetesServiceAccount
	}
	return nil
}

func (m *Resource) GetAmazonEks() *AmazonEKS {
	if x, ok := m.GetResource().(*Resource_AmazonEks); ok {
		return x.AmazonEks
	}
	return nil
}

func (m *Resource) GetGoogleGke() *GoogleGKE {
	if x, ok := m.GetResource().(*Resource_GoogleGke); ok {
		return x.GoogleGke
	}
	return nil
}

func (m *Resource) GetAks() *AKS {
	if x, ok := m.GetResource().(*Resource_Aks); ok {
		return x.Aks
	}
	return nil
}

func (m *Resource) GetAksBasicAuth() *AKSBasicAuth {
	if x, ok := m.GetResource().(*Resource_AksBasicAuth); ok {
		return x.AksBasicAuth
	}
	return nil
}

func (m *Resource) GetAksServiceAccount() *AKSServiceAccount {
	if x, ok := m.GetResource().(*Resource_AksServiceAccount); ok {
		return x.AksServiceAccount
	}
	return nil
}

func (m *Resource) GetMemcached() *Memcached {
	if x, ok := m.GetResource().(*Resource_Memcached); ok {
		return x.Memcached
	}
	return nil
}

func (m *Resource) GetMongoLegacyHost() *MongoLegacyHost {
	if x, ok := m.GetResource().(*Resource_MongoLegacyHost); ok {
		return x.MongoLegacyHost
	}
	return nil
}

func (m *Resource) GetMongoLegacyReplicaset() *MongoLegacyReplicaset {
	if x, ok := m.GetResource().(*Resource_MongoLegacyReplicaset); ok {
		return x.MongoLegacyReplicaset
	}
	return nil
}

func (m *Resource) GetMongoHost() *MongoHost {
	if x, ok := m.GetResource().(*Resource_MongoHost); ok {
		return x.MongoHost
	}
	return nil
}

func (m *Resource) GetMongoReplicaSet() *MongoReplicaSet {
	if x, ok := m.GetResource().(*Resource_MongoReplicaSet); ok {
		return x.MongoReplicaSet
	}
	return nil
}

func (m *Resource) GetMysql() *Mysql {
	if x, ok := m.GetResource().(*Resource_Mysql); ok {
		return x.Mysql
	}
	return nil
}

func (m *Resource) GetAuroraMysql() *AuroraMysql {
	if x, ok := m.GetResource().(*Resource_AuroraMysql); ok {
		return x.AuroraMysql
	}
	return nil
}

func (m *Resource) GetClustrix() *Clustrix {
	if x, ok := m.GetResource().(*Resource_Clustrix); ok {
		return x.Clustrix
	}
	return nil
}

func (m *Resource) GetMaria() *Maria {
	if x, ok := m.GetResource().(*Resource_Maria); ok {
		return x.Maria
	}
	return nil
}

func (m *Resource) GetMemsql() *Memsql {
	if x, ok := m.GetResource().(*Resource_Memsql); ok {
		return x.Memsql
	}
	return nil
}

func (m *Resource) GetOracle() *Oracle {
	if x, ok := m.GetResource().(*Resource_Oracle); ok {
		return x.Oracle
	}
	return nil
}

func (m *Resource) GetPostgres() *Postgres {
	if x, ok := m.GetResource().(*Resource_Postgres); ok {
		return x.Postgres
	}
	return nil
}

func (m *Resource) GetAuroraPostgres() *AuroraPostgres {
	if x, ok := m.GetResource().(*Resource_AuroraPostgres); ok {
		return x.AuroraPostgres
	}
	return nil
}

func (m *Resource) GetGreenplum() *Greenplum {
	if x, ok := m.GetResource().(*Resource_Greenplum); ok {
		return x.Greenplum
	}
	return nil
}

func (m *Resource) GetCockroach() *Cockroach {
	if x, ok := m.GetResource().(*Resource_Cockroach); ok {
		return x.Cockroach
	}
	return nil
}

func (m *Resource) GetRedshift() *Redshift {
	if x, ok := m.GetResource().(*Resource_Redshift); ok {
		return x.Redshift
	}
	return nil
}

func (m *Resource) GetPresto() *Presto {
	if x, ok := m.GetResource().(*Resource_Presto); ok {
		return x.Presto
	}
	return nil
}

func (m *Resource) GetRdp() *RDP {
	if x, ok := m.GetResource().(*Resource_Rdp); ok {
		return x.Rdp
	}
	return nil
}

func (m *Resource) GetRedis() *Redis {
	if x, ok := m.GetResource().(*Resource_Redis); ok {
		return x.Redis
	}
	return nil
}

func (m *Resource) GetElasticacheRedis() *ElasticacheRedis {
	if x, ok := m.GetResource().(*Resource_ElasticacheRedis); ok {
		return x.ElasticacheRedis
	}
	return nil
}

func (m *Resource) GetSnowflake() *Snowflake {
	if x, ok := m.GetResource().(*Resource_Snowflake); ok {
		return x.Snowflake
	}
	return nil
}

func (m *Resource) GetSqlServer() *SQLServer {
	if x, ok := m.GetResource().(*Resource_SqlServer); ok {
		return x.SqlServer
	}
	return nil
}

func (m *Resource) GetSsh() *SSH {
	if x, ok := m.GetResource().(*Resource_Ssh); ok {
		return x.Ssh
	}
	return nil
}

func (m *Resource) GetSybase() *Sybase {
	if x, ok := m.GetResource().(*Resource_Sybase); ok {
		return x.Sybase
	}
	return nil
}

func (m *Resource) GetSybaseIq() *SybaseIQ {
	if x, ok := m.GetResource().(*Resource_SybaseIq); ok {
		return x.SybaseIq
	}
	return nil
}

func (m *Resource) GetTeradata() *Teradata {
	if x, ok := m.GetResource().(*Resource_Teradata); ok {
		return x.Teradata
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Resource) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Resource_Athena)(nil),
		(*Resource_BigQuery)(nil),
		(*Resource_Cassandra)(nil),
		(*Resource_Druid)(nil),
		(*Resource_DynamoDb)(nil),
		(*Resource_AmazonEs)(nil),
		(*Resource_Elastic)(nil),
		(*Resource_HttpBasicAuth)(nil),
		(*Resource_HttpNoAuth)(nil),
		(*Resource_HttpAuth)(nil),
		(*Resource_Kubernetes)(nil),
		(*Resource_KubernetesBasicAuth)(nil),
		(*Resource_KubernetesServiceAccount)(nil),
		(*Resource_AmazonEks)(nil),
		(*Resource_GoogleGke)(nil),
		(*Resource_Aks)(nil),
		(*Resource_AksBasicAuth)(nil),
		(*Resource_AksServiceAccount)(nil),
		(*Resource_Memcached)(nil),
		(*Resource_MongoLegacyHost)(nil),
		(*Resource_MongoLegacyReplicaset)(nil),
		(*Resource_MongoHost)(nil),
		(*Resource_MongoReplicaSet)(nil),
		(*Resource_Mysql)(nil),
		(*Resource_AuroraMysql)(nil),
		(*Resource_Clustrix)(nil),
		(*Resource_Maria)(nil),
		(*Resource_Memsql)(nil),
		(*Resource_Oracle)(nil),
		(*Resource_Postgres)(nil),
		(*Resource_AuroraPostgres)(nil),
		(*Resource_Greenplum)(nil),
		(*Resource_Cockroach)(nil),
		(*Resource_Redshift)(nil),
		(*Resource_Presto)(nil),
		(*Resource_Rdp)(nil),
		(*Resource_Redis)(nil),
		(*Resource_ElasticacheRedis)(nil),
		(*Resource_Snowflake)(nil),
		(*Resource_SqlServer)(nil),
		(*Resource_Ssh)(nil),
		(*Resource_Sybase)(nil),
		(*Resource_SybaseIq)(nil),
		(*Resource_Teradata)(nil),
	}
}

type Athena struct {
	// Unique identifier of the Resource.
	Id string `protobuf:"bytes,32768,opt,name=id,proto3" json:"id,omitempty"`
	// Unique human-readable name of the Resource.
	Name string `protobuf:"bytes,32769,opt,name=name,proto3" json:"name,omitempty"`
	// True if the datasource is reachable and the credentials are valid.
	Healthy bool `protobuf:"varint,32770,opt,name=healthy,proto3" json:"healthy,omitempty"`
	// Tags is a map of key, value pairs.
	Tags                 []*Pair  `protobuf:"bytes,32771,rep,name=tags,proto3" json:"tags,omitempty"`
	AccessKey            string   `protobuf:"bytes,1,opt,name=access_key,json=accessKey,proto3" json:"access_key,omitempty"`
	SecretAccessKey      string   `protobuf:"bytes,2,opt,name=secret_access_key,json=secretAccessKey,proto3" json:"secret_access_key,omitempty"`
	Output               string   `protobuf:"bytes,3,opt,name=output,proto3" json:"output,omitempty"`
	PortOverride         int32    `protobuf:"varint,4,opt,name=port_override,json=portOverride,proto3" json:"port_override,omitempty"`
	Region               string   `protobuf:"bytes,5,opt,name=region,proto3" json:"region,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Athena) Reset()         { *m = Athena{} }
func (m *Athena) String() string { return proto.CompactTextString(m) }
func (*Athena) ProtoMessage()    {}
func (*Athena) Descriptor() ([]byte, []int) {
	return fileDescriptor_81dfd49b5b303fb4, []int{1}
}

func (m *Athena) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Athena.Unmarshal(m, b)
}
func (m *Athena) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Athena.Marshal(b, m, deterministic)
}
func (m *Athena) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Athena.Merge(m, src)
}
func (m *Athena) XXX_Size() int {
	return xxx_messageInfo_Athena.Size(m)
}
func (m *Athena) XXX_DiscardUnknown() {
	xxx_messageInfo_Athena.DiscardUnknown(m)
}

var xxx_messageInfo_Athena proto.InternalMessageInfo

func (m *Athena) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Athena) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Athena) GetHealthy() bool {
	if m != nil {
		return m.Healthy
	}
	return false
}

func (m *Athena) GetTags() []*Pair {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *Athena) GetAccessKey() string {
	if m != nil {
		return m.AccessKey
	}
	return ""
}

func (m *Athena) GetSecretAccessKey() string {
	if m != nil {
		return m.SecretAccessKey
	}
	return ""
}

func (m *Athena) GetOutput() string {
	if m != nil {
		return m.Output
	}
	return ""
}

func (m *Athena) GetPortOverride() int32 {
	if m != nil {
		return m.PortOverride
	}
	return 0
}

func (m *Athena) GetRegion() string {
	if m != nil {
		return m.Region
	}
	return ""
}

type BigQuery struct {
	// Unique identifier of the Resource.
	Id string `protobuf:"bytes,32768,opt,name=id,proto3" json:"id,omitempty"`
	// Unique human-readable name of the Resource.
	Name string `protobuf:"bytes,32769,opt,name=name,proto3" json:"name,omitempty"`
	// True if the datasource is reachable and the credentials are valid.
	Healthy bool `protobuf:"varint,32770,opt,name=healthy,proto3" json:"healthy,omitempty"`
	// Tags is a map of key, value pairs.
	Tags                 []*Pair  `protobuf:"bytes,32771,rep,name=tags,proto3" json:"tags,omitempty"`
	PrivateKey           string   `protobuf:"bytes,1,opt,name=private_key,json=privateKey,proto3" json:"private_key,omitempty"`
	Project              string   `protobuf:"bytes,2,opt,name=project,proto3" json:"project,omitempty"`
	PortOverride         int32    `protobuf:"varint,3,opt,name=port_override,json=portOverride,proto3" json:"port_override,omitempty"`
	Endpoint             string   `protobuf:"bytes,4,opt,name=endpoint,proto3" json:"endpoint,omitempty"`
	Username             string   `protobuf:"bytes,5,opt,name=username,proto3" json:"username,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BigQuery) Reset()         { *m = BigQuery{} }
func (m *BigQuery) String() string { return proto.CompactTextString(m) }
func (*BigQuery) ProtoMessage()    {}
func (*BigQuery) Descriptor() ([]byte, []int) {
	return fileDescriptor_81dfd49b5b303fb4, []int{2}
}

func (m *BigQuery) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_BigQuery.Unmarshal(m, b)
}
func (m *BigQuery) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_BigQuery.Marshal(b, m, deterministic)
}
func (m *BigQuery) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BigQuery.Merge(m, src)
}
func (m *BigQuery) XXX_Size() int {
	return xxx_messageInfo_BigQuery.Size(m)
}
func (m *BigQuery) XXX_DiscardUnknown() {
	xxx_messageInfo_BigQuery.DiscardUnknown(m)
}

var xxx_messageInfo_BigQuery proto.InternalMessageInfo

func (m *BigQuery) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *BigQuery) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *BigQuery) GetHealthy() bool {
	if m != nil {
		return m.Healthy
	}
	return false
}

func (m *BigQuery) GetTags() []*Pair {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *BigQuery) GetPrivateKey() string {
	if m != nil {
		return m.PrivateKey
	}
	return ""
}

func (m *BigQuery) GetProject() string {
	if m != nil {
		return m.Project
	}
	return ""
}

func (m *BigQuery) GetPortOverride() int32 {
	if m != nil {
		return m.PortOverride
	}
	return 0
}

func (m *BigQuery) GetEndpoint() string {
	if m != nil {
		return m.Endpoint
	}
	return ""
}

func (m *BigQuery) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

type Cassandra struct {
	// Unique identifier of the Resource.
	Id string `protobuf:"bytes,32768,opt,name=id,proto3" json:"id,omitempty"`
	// Unique human-readable name of the Resource.
	Name string `protobuf:"bytes,32769,opt,name=name,proto3" json:"name,omitempty"`
	// True if the datasource is reachable and the credentials are valid.
	Healthy bool `protobuf:"varint,32770,opt,name=healthy,proto3" json:"healthy,omitempty"`
	// Tags is a map of key, value pairs.
	Tags                 []*Pair  `protobuf:"bytes,32771,rep,name=tags,proto3" json:"tags,omitempty"`
	Hostname             string   `protobuf:"bytes,1,opt,name=hostname,proto3" json:"hostname,omitempty"`
	Username             string   `protobuf:"bytes,2,opt,name=username,proto3" json:"username,omitempty"`
	Password             string   `protobuf:"bytes,3,opt,name=password,proto3" json:"password,omitempty"`
	PortOverride         int32    `protobuf:"varint,4,opt,name=port_override,json=portOverride,proto3" json:"port_override,omitempty"`
	Port                 int32    `protobuf:"varint,5,opt,name=port,proto3" json:"port,omitempty"`
	TlsRequired          bool     `protobuf:"varint,6,opt,name=tls_required,json=tlsRequired,proto3" json:"tls_required,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Cassandra) Reset()         { *m = Cassandra{} }
func (m *Cassandra) String() string { return proto.CompactTextString(m) }
func (*Cassandra) ProtoMessage()    {}
func (*Cassandra) Descriptor() ([]byte, []int) {
	return fileDescriptor_81dfd49b5b303fb4, []int{3}
}

func (m *Cassandra) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Cassandra.Unmarshal(m, b)
}
func (m *Cassandra) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Cassandra.Marshal(b, m, deterministic)
}
func (m *Cassandra) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Cassandra.Merge(m, src)
}
func (m *Cassandra) XXX_Size() int {
	return xxx_messageInfo_Cassandra.Size(m)
}
func (m *Cassandra) XXX_DiscardUnknown() {
	xxx_messageInfo_Cassandra.DiscardUnknown(m)
}

var xxx_messageInfo_Cassandra proto.InternalMessageInfo

func (m *Cassandra) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Cassandra) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Cassandra) GetHealthy() bool {
	if m != nil {
		return m.Healthy
	}
	return false
}

func (m *Cassandra) GetTags() []*Pair {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *Cassandra) GetHostname() string {
	if m != nil {
		return m.Hostname
	}
	return ""
}

func (m *Cassandra) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *Cassandra) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

func (m *Cassandra) GetPortOverride() int32 {
	if m != nil {
		return m.PortOverride
	}
	return 0
}

func (m *Cassandra) GetPort() int32 {
	if m != nil {
		return m.Port
	}
	return 0
}

func (m *Cassandra) GetTlsRequired() bool {
	if m != nil {
		return m.TlsRequired
	}
	return false
}

type Druid struct {
	// Unique identifier of the Resource.
	Id string `protobuf:"bytes,32768,opt,name=id,proto3" json:"id,omitempty"`
	// Unique human-readable name of the Resource.
	Name string `protobuf:"bytes,32769,opt,name=name,proto3" json:"name,omitempty"`
	// True if the datasource is reachable and the credentials are valid.
	Healthy bool `protobuf:"varint,32770,opt,name=healthy,proto3" json:"healthy,omitempty"`
	// Tags is a map of key, value pairs.
	Tags                 []*Pair  `protobuf:"bytes,32771,rep,name=tags,proto3" json:"tags,omitempty"`
	Hostname             string   `protobuf:"bytes,1,opt,name=hostname,proto3" json:"hostname,omitempty"`
	PortOverride         int32    `protobuf:"varint,2,opt,name=port_override,json=portOverride,proto3" json:"port_override,omitempty"`
	Username             string   `protobuf:"bytes,3,opt,name=username,proto3" json:"username,omitempty"`
	Password             string   `protobuf:"bytes,4,opt,name=password,proto3" json:"password,omitempty"`
	Port                 int32    `protobuf:"varint,5,opt,name=port,proto3" json:"port,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Druid) Reset()         { *m = Druid{} }
func (m *Druid) String() string { return proto.CompactTextString(m) }
func (*Druid) ProtoMessage()    {}
func (*Druid) Descriptor() ([]byte, []int) {
	return fileDescriptor_81dfd49b5b303fb4, []int{4}
}

func (m *Druid) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Druid.Unmarshal(m, b)
}
func (m *Druid) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Druid.Marshal(b, m, deterministic)
}
func (m *Druid) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Druid.Merge(m, src)
}
func (m *Druid) XXX_Size() int {
	return xxx_messageInfo_Druid.Size(m)
}
func (m *Druid) XXX_DiscardUnknown() {
	xxx_messageInfo_Druid.DiscardUnknown(m)
}

var xxx_messageInfo_Druid proto.InternalMessageInfo

func (m *Druid) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Druid) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Druid) GetHealthy() bool {
	if m != nil {
		return m.Healthy
	}
	return false
}

func (m *Druid) GetTags() []*Pair {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *Druid) GetHostname() string {
	if m != nil {
		return m.Hostname
	}
	return ""
}

func (m *Druid) GetPortOverride() int32 {
	if m != nil {
		return m.PortOverride
	}
	return 0
}

func (m *Druid) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *Druid) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

func (m *Druid) GetPort() int32 {
	if m != nil {
		return m.Port
	}
	return 0
}

type DynamoDB struct {
	// Unique identifier of the Resource.
	Id string `protobuf:"bytes,32768,opt,name=id,proto3" json:"id,omitempty"`
	// Unique human-readable name of the Resource.
	Name string `protobuf:"bytes,32769,opt,name=name,proto3" json:"name,omitempty"`
	// True if the datasource is reachable and the credentials are valid.
	Healthy bool `protobuf:"varint,32770,opt,name=healthy,proto3" json:"healthy,omitempty"`
	// Tags is a map of key, value pairs.
	Tags                 []*Pair  `protobuf:"bytes,32771,rep,name=tags,proto3" json:"tags,omitempty"`
	AccessKey            string   `protobuf:"bytes,1,opt,name=access_key,json=accessKey,proto3" json:"access_key,omitempty"`
	SecretAccessKey      string   `protobuf:"bytes,2,opt,name=secret_access_key,json=secretAccessKey,proto3" json:"secret_access_key,omitempty"`
	Region               string   `protobuf:"bytes,3,opt,name=region,proto3" json:"region,omitempty"`
	Endpoint             string   `protobuf:"bytes,4,opt,name=endpoint,proto3" json:"endpoint,omitempty"`
	PortOverride         int32    `protobuf:"varint,5,opt,name=port_override,json=portOverride,proto3" json:"port_override,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DynamoDB) Reset()         { *m = DynamoDB{} }
func (m *DynamoDB) String() string { return proto.CompactTextString(m) }
func (*DynamoDB) ProtoMessage()    {}
func (*DynamoDB) Descriptor() ([]byte, []int) {
	return fileDescriptor_81dfd49b5b303fb4, []int{5}
}

func (m *DynamoDB) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DynamoDB.Unmarshal(m, b)
}
func (m *DynamoDB) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DynamoDB.Marshal(b, m, deterministic)
}
func (m *DynamoDB) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DynamoDB.Merge(m, src)
}
func (m *DynamoDB) XXX_Size() int {
	return xxx_messageInfo_DynamoDB.Size(m)
}
func (m *DynamoDB) XXX_DiscardUnknown() {
	xxx_messageInfo_DynamoDB.DiscardUnknown(m)
}

var xxx_messageInfo_DynamoDB proto.InternalMessageInfo

func (m *DynamoDB) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *DynamoDB) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *DynamoDB) GetHealthy() bool {
	if m != nil {
		return m.Healthy
	}
	return false
}

func (m *DynamoDB) GetTags() []*Pair {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *DynamoDB) GetAccessKey() string {
	if m != nil {
		return m.AccessKey
	}
	return ""
}

func (m *DynamoDB) GetSecretAccessKey() string {
	if m != nil {
		return m.SecretAccessKey
	}
	return ""
}

func (m *DynamoDB) GetRegion() string {
	if m != nil {
		return m.Region
	}
	return ""
}

func (m *DynamoDB) GetEndpoint() string {
	if m != nil {
		return m.Endpoint
	}
	return ""
}

func (m *DynamoDB) GetPortOverride() int32 {
	if m != nil {
		return m.PortOverride
	}
	return 0
}

type AmazonES struct {
	// Unique identifier of the Resource.
	Id string `protobuf:"bytes,32768,opt,name=id,proto3" json:"id,omitempty"`
	// Unique human-readable name of the Resource.
	Name string `protobuf:"bytes,32769,opt,name=name,proto3" json:"name,omitempty"`
	// True if the datasource is reachable and the credentials are valid.
	Healthy bool `protobuf:"varint,32770,opt,name=healthy,proto3" json:"healthy,omitempty"`
	// Tags is a map of key, value pairs.
	Tags                 []*Pair  `protobuf:"bytes,32771,rep,name=tags,proto3" json:"tags,omitempty"`
	Region               string   `protobuf:"bytes,1,opt,name=region,proto3" json:"region,omitempty"`
	SecretAccessKey      string   `protobuf:"bytes,2,opt,name=secret_access_key,json=secretAccessKey,proto3" json:"secret_access_key,omitempty"`
	Endpoint             string   `protobuf:"bytes,3,opt,name=endpoint,proto3" json:"endpoint,omitempty"`
	AccessKey            string   `protobuf:"bytes,4,opt,name=access_key,json=accessKey,proto3" json:"access_key,omitempty"`
	PortOverride         int32    `protobuf:"varint,5,opt,name=port_override,json=portOverride,proto3" json:"port_override,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AmazonES) Reset()         { *m = AmazonES{} }
func (m *AmazonES) String() string { return proto.CompactTextString(m) }
func (*AmazonES) ProtoMessage()    {}
func (*AmazonES) Descriptor() ([]byte, []int) {
	return fileDescriptor_81dfd49b5b303fb4, []int{6}
}

func (m *AmazonES) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AmazonES.Unmarshal(m, b)
}
func (m *AmazonES) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AmazonES.Marshal(b, m, deterministic)
}
func (m *AmazonES) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AmazonES.Merge(m, src)
}
func (m *AmazonES) XXX_Size() int {
	return xxx_messageInfo_AmazonES.Size(m)
}
func (m *AmazonES) XXX_DiscardUnknown() {
	xxx_messageInfo_AmazonES.DiscardUnknown(m)
}

var xxx_messageInfo_AmazonES proto.InternalMessageInfo

func (m *AmazonES) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *AmazonES) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *AmazonES) GetHealthy() bool {
	if m != nil {
		return m.Healthy
	}
	return false
}

func (m *AmazonES) GetTags() []*Pair {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *AmazonES) GetRegion() string {
	if m != nil {
		return m.Region
	}
	return ""
}

func (m *AmazonES) GetSecretAccessKey() string {
	if m != nil {
		return m.SecretAccessKey
	}
	return ""
}

func (m *AmazonES) GetEndpoint() string {
	if m != nil {
		return m.Endpoint
	}
	return ""
}

func (m *AmazonES) GetAccessKey() string {
	if m != nil {
		return m.AccessKey
	}
	return ""
}

func (m *AmazonES) GetPortOverride() int32 {
	if m != nil {
		return m.PortOverride
	}
	return 0
}

type Elastic struct {
	// Unique identifier of the Resource.
	Id string `protobuf:"bytes,32768,opt,name=id,proto3" json:"id,omitempty"`
	// Unique human-readable name of the Resource.
	Name string `protobuf:"bytes,32769,opt,name=name,proto3" json:"name,omitempty"`
	// True if the datasource is reachable and the credentials are valid.
	Healthy bool `protobuf:"varint,32770,opt,name=healthy,proto3" json:"healthy,omitempty"`
	// Tags is a map of key, value pairs.
	Tags                 []*Pair  `protobuf:"bytes,32771,rep,name=tags,proto3" json:"tags,omitempty"`
	Hostname             string   `protobuf:"bytes,1,opt,name=hostname,proto3" json:"hostname,omitempty"`
	Username             string   `protobuf:"bytes,2,opt,name=username,proto3" json:"username,omitempty"`
	Password             string   `protobuf:"bytes,3,opt,name=password,proto3" json:"password,omitempty"`
	PortOverride         int32    `protobuf:"varint,4,opt,name=port_override,json=portOverride,proto3" json:"port_override,omitempty"`
	Port                 int32    `protobuf:"varint,5,opt,name=port,proto3" json:"port,omitempty"`
	TlsRequired          bool     `protobuf:"varint,6,opt,name=tls_required,json=tlsRequired,proto3" json:"tls_required,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Elastic) Reset()         { *m = Elastic{} }
func (m *Elastic) String() string { return proto.CompactTextString(m) }
func (*Elastic) ProtoMessage()    {}
func (*Elastic) Descriptor() ([]byte, []int) {
	return fileDescriptor_81dfd49b5b303fb4, []int{7}
}

func (m *Elastic) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Elastic.Unmarshal(m, b)
}
func (m *Elastic) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Elastic.Marshal(b, m, deterministic)
}
func (m *Elastic) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Elastic.Merge(m, src)
}
func (m *Elastic) XXX_Size() int {
	return xxx_messageInfo_Elastic.Size(m)
}
func (m *Elastic) XXX_DiscardUnknown() {
	xxx_messageInfo_Elastic.DiscardUnknown(m)
}

var xxx_messageInfo_Elastic proto.InternalMessageInfo

func (m *Elastic) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Elastic) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Elastic) GetHealthy() bool {
	if m != nil {
		return m.Healthy
	}
	return false
}

func (m *Elastic) GetTags() []*Pair {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *Elastic) GetHostname() string {
	if m != nil {
		return m.Hostname
	}
	return ""
}

func (m *Elastic) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *Elastic) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

func (m *Elastic) GetPortOverride() int32 {
	if m != nil {
		return m.PortOverride
	}
	return 0
}

func (m *Elastic) GetPort() int32 {
	if m != nil {
		return m.Port
	}
	return 0
}

func (m *Elastic) GetTlsRequired() bool {
	if m != nil {
		return m.TlsRequired
	}
	return false
}

type HTTPBasicAuth struct {
	// Unique identifier of the Resource.
	Id string `protobuf:"bytes,32768,opt,name=id,proto3" json:"id,omitempty"`
	// Unique human-readable name of the Resource.
	Name string `protobuf:"bytes,32769,opt,name=name,proto3" json:"name,omitempty"`
	// True if the datasource is reachable and the credentials are valid.
	Healthy bool `protobuf:"varint,32770,opt,name=healthy,proto3" json:"healthy,omitempty"`
	// Tags is a map of key, value pairs.
	Tags                 []*Pair  `protobuf:"bytes,32771,rep,name=tags,proto3" json:"tags,omitempty"`
	Url                  string   `protobuf:"bytes,1,opt,name=url,proto3" json:"url,omitempty"`
	HealthcheckPath      string   `protobuf:"bytes,2,opt,name=healthcheck_path,json=healthcheckPath,proto3" json:"healthcheck_path,omitempty"`
	Username             string   `protobuf:"bytes,3,opt,name=username,proto3" json:"username,omitempty"`
	Password             string   `protobuf:"bytes,4,opt,name=password,proto3" json:"password,omitempty"`
	HeadersBlacklist     string   `protobuf:"bytes,5,opt,name=headers_blacklist,json=headersBlacklist,proto3" json:"headers_blacklist,omitempty"`
	DefaultPath          string   `protobuf:"bytes,6,opt,name=default_path,json=defaultPath,proto3" json:"default_path,omitempty"`
	Subdomain            string   `protobuf:"bytes,7,opt,name=subdomain,proto3" json:"subdomain,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *HTTPBasicAuth) Reset()         { *m = HTTPBasicAuth{} }
func (m *HTTPBasicAuth) String() string { return proto.CompactTextString(m) }
func (*HTTPBasicAuth) ProtoMessage()    {}
func (*HTTPBasicAuth) Descriptor() ([]byte, []int) {
	return fileDescriptor_81dfd49b5b303fb4, []int{8}
}

func (m *HTTPBasicAuth) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_HTTPBasicAuth.Unmarshal(m, b)
}
func (m *HTTPBasicAuth) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_HTTPBasicAuth.Marshal(b, m, deterministic)
}
func (m *HTTPBasicAuth) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HTTPBasicAuth.Merge(m, src)
}
func (m *HTTPBasicAuth) XXX_Size() int {
	return xxx_messageInfo_HTTPBasicAuth.Size(m)
}
func (m *HTTPBasicAuth) XXX_DiscardUnknown() {
	xxx_messageInfo_HTTPBasicAuth.DiscardUnknown(m)
}

var xxx_messageInfo_HTTPBasicAuth proto.InternalMessageInfo

func (m *HTTPBasicAuth) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *HTTPBasicAuth) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *HTTPBasicAuth) GetHealthy() bool {
	if m != nil {
		return m.Healthy
	}
	return false
}

func (m *HTTPBasicAuth) GetTags() []*Pair {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *HTTPBasicAuth) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *HTTPBasicAuth) GetHealthcheckPath() string {
	if m != nil {
		return m.HealthcheckPath
	}
	return ""
}

func (m *HTTPBasicAuth) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *HTTPBasicAuth) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

func (m *HTTPBasicAuth) GetHeadersBlacklist() string {
	if m != nil {
		return m.HeadersBlacklist
	}
	return ""
}

func (m *HTTPBasicAuth) GetDefaultPath() string {
	if m != nil {
		return m.DefaultPath
	}
	return ""
}

func (m *HTTPBasicAuth) GetSubdomain() string {
	if m != nil {
		return m.Subdomain
	}
	return ""
}

type HTTPNoAuth struct {
	// Unique identifier of the Resource.
	Id string `protobuf:"bytes,32768,opt,name=id,proto3" json:"id,omitempty"`
	// Unique human-readable name of the Resource.
	Name string `protobuf:"bytes,32769,opt,name=name,proto3" json:"name,omitempty"`
	// True if the datasource is reachable and the credentials are valid.
	Healthy bool `protobuf:"varint,32770,opt,name=healthy,proto3" json:"healthy,omitempty"`
	// Tags is a map of key, value pairs.
	Tags                 []*Pair  `protobuf:"bytes,32771,rep,name=tags,proto3" json:"tags,omitempty"`
	Url                  string   `protobuf:"bytes,1,opt,name=url,proto3" json:"url,omitempty"`
	HealthcheckPath      string   `protobuf:"bytes,2,opt,name=healthcheck_path,json=healthcheckPath,proto3" json:"healthcheck_path,omitempty"`
	HeadersBlacklist     string   `protobuf:"bytes,3,opt,name=headers_blacklist,json=headersBlacklist,proto3" json:"headers_blacklist,omitempty"`
	DefaultPath          string   `protobuf:"bytes,4,opt,name=default_path,json=defaultPath,proto3" json:"default_path,omitempty"`
	Subdomain            string   `protobuf:"bytes,5,opt,name=subdomain,proto3" json:"subdomain,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *HTTPNoAuth) Reset()         { *m = HTTPNoAuth{} }
func (m *HTTPNoAuth) String() string { return proto.CompactTextString(m) }
func (*HTTPNoAuth) ProtoMessage()    {}
func (*HTTPNoAuth) Descriptor() ([]byte, []int) {
	return fileDescriptor_81dfd49b5b303fb4, []int{9}
}

func (m *HTTPNoAuth) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_HTTPNoAuth.Unmarshal(m, b)
}
func (m *HTTPNoAuth) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_HTTPNoAuth.Marshal(b, m, deterministic)
}
func (m *HTTPNoAuth) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HTTPNoAuth.Merge(m, src)
}
func (m *HTTPNoAuth) XXX_Size() int {
	return xxx_messageInfo_HTTPNoAuth.Size(m)
}
func (m *HTTPNoAuth) XXX_DiscardUnknown() {
	xxx_messageInfo_HTTPNoAuth.DiscardUnknown(m)
}

var xxx_messageInfo_HTTPNoAuth proto.InternalMessageInfo

func (m *HTTPNoAuth) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *HTTPNoAuth) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *HTTPNoAuth) GetHealthy() bool {
	if m != nil {
		return m.Healthy
	}
	return false
}

func (m *HTTPNoAuth) GetTags() []*Pair {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *HTTPNoAuth) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *HTTPNoAuth) GetHealthcheckPath() string {
	if m != nil {
		return m.HealthcheckPath
	}
	return ""
}

func (m *HTTPNoAuth) GetHeadersBlacklist() string {
	if m != nil {
		return m.HeadersBlacklist
	}
	return ""
}

func (m *HTTPNoAuth) GetDefaultPath() string {
	if m != nil {
		return m.DefaultPath
	}
	return ""
}

func (m *HTTPNoAuth) GetSubdomain() string {
	if m != nil {
		return m.Subdomain
	}
	return ""
}

type HTTPAuth struct {
	// Unique identifier of the Resource.
	Id string `protobuf:"bytes,32768,opt,name=id,proto3" json:"id,omitempty"`
	// Unique human-readable name of the Resource.
	Name string `protobuf:"bytes,32769,opt,name=name,proto3" json:"name,omitempty"`
	// True if the datasource is reachable and the credentials are valid.
	Healthy bool `protobuf:"varint,32770,opt,name=healthy,proto3" json:"healthy,omitempty"`
	// Tags is a map of key, value pairs.
	Tags                 []*Pair  `protobuf:"bytes,32771,rep,name=tags,proto3" json:"tags,omitempty"`
	Url                  string   `protobuf:"bytes,1,opt,name=url,proto3" json:"url,omitempty"`
	HealthcheckPath      string   `protobuf:"bytes,2,opt,name=healthcheck_path,json=healthcheckPath,proto3" json:"healthcheck_path,omitempty"`
	AuthHeader           string   `protobuf:"bytes,3,opt,name=auth_header,json=authHeader,proto3" json:"auth_header,omitempty"`
	HeadersBlacklist     string   `protobuf:"bytes,4,opt,name=headers_blacklist,json=headersBlacklist,proto3" json:"headers_blacklist,omitempty"`
	DefaultPath          string   `protobuf:"bytes,5,opt,name=default_path,json=defaultPath,proto3" json:"default_path,omitempty"`
	Subdomain            string   `protobuf:"bytes,6,opt,name=subdomain,proto3" json:"subdomain,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *HTTPAuth) Reset()         { *m = HTTPAuth{} }
func (m *HTTPAuth) String() string { return proto.CompactTextString(m) }
func (*HTTPAuth) ProtoMessage()    {}
func (*HTTPAuth) Descriptor() ([]byte, []int) {
	return fileDescriptor_81dfd49b5b303fb4, []int{10}
}

func (m *HTTPAuth) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_HTTPAuth.Unmarshal(m, b)
}
func (m *HTTPAuth) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_HTTPAuth.Marshal(b, m, deterministic)
}
func (m *HTTPAuth) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HTTPAuth.Merge(m, src)
}
func (m *HTTPAuth) XXX_Size() int {
	return xxx_messageInfo_HTTPAuth.Size(m)
}
func (m *HTTPAuth) XXX_DiscardUnknown() {
	xxx_messageInfo_HTTPAuth.DiscardUnknown(m)
}

var xxx_messageInfo_HTTPAuth proto.InternalMessageInfo

func (m *HTTPAuth) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *HTTPAuth) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *HTTPAuth) GetHealthy() bool {
	if m != nil {
		return m.Healthy
	}
	return false
}

func (m *HTTPAuth) GetTags() []*Pair {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *HTTPAuth) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *HTTPAuth) GetHealthcheckPath() string {
	if m != nil {
		return m.HealthcheckPath
	}
	return ""
}

func (m *HTTPAuth) GetAuthHeader() string {
	if m != nil {
		return m.AuthHeader
	}
	return ""
}

func (m *HTTPAuth) GetHeadersBlacklist() string {
	if m != nil {
		return m.HeadersBlacklist
	}
	return ""
}

func (m *HTTPAuth) GetDefaultPath() string {
	if m != nil {
		return m.DefaultPath
	}
	return ""
}

func (m *HTTPAuth) GetSubdomain() string {
	if m != nil {
		return m.Subdomain
	}
	return ""
}

type Kubernetes struct {
	// Unique identifier of the Resource.
	Id string `protobuf:"bytes,32768,opt,name=id,proto3" json:"id,omitempty"`
	// Unique human-readable name of the Resource.
	Name string `protobuf:"bytes,32769,opt,name=name,proto3" json:"name,omitempty"`
	// True if the datasource is reachable and the credentials are valid.
	Healthy bool `protobuf:"varint,32770,opt,name=healthy,proto3" json:"healthy,omitempty"`
	// Tags is a map of key, value pairs.
	Tags                         []*Pair  `protobuf:"bytes,32771,rep,name=tags,proto3" json:"tags,omitempty"`
	Hostname                     string   `protobuf:"bytes,1,opt,name=hostname,proto3" json:"hostname,omitempty"`
	Port                         int32    `protobuf:"varint,2,opt,name=port,proto3" json:"port,omitempty"`
	CertificateAuthority         string   `protobuf:"bytes,3,opt,name=certificate_authority,json=certificateAuthority,proto3" json:"certificate_authority,omitempty"`
	CertificateAuthorityFilename string   `protobuf:"bytes,4,opt,name=certificate_authority_filename,json=certificateAuthorityFilename,proto3" json:"certificate_authority_filename,omitempty"`
	ClientCertificate            string   `protobuf:"bytes,5,opt,name=client_certificate,json=clientCertificate,proto3" json:"client_certificate,omitempty"`
	ClientCertificateFilename    string   `protobuf:"bytes,6,opt,name=client_certificate_filename,json=clientCertificateFilename,proto3" json:"client_certificate_filename,omitempty"`
	ClientKey                    string   `protobuf:"bytes,7,opt,name=client_key,json=clientKey,proto3" json:"client_key,omitempty"`
	ClientKeyFilename            string   `protobuf:"bytes,8,opt,name=client_key_filename,json=clientKeyFilename,proto3" json:"client_key_filename,omitempty"`
	XXX_NoUnkeyedLiteral         struct{} `json:"-"`
	XXX_unrecognized             []byte   `json:"-"`
	XXX_sizecache                int32    `json:"-"`
}

func (m *Kubernetes) Reset()         { *m = Kubernetes{} }
func (m *Kubernetes) String() string { return proto.CompactTextString(m) }
func (*Kubernetes) ProtoMessage()    {}
func (*Kubernetes) Descriptor() ([]byte, []int) {
	return fileDescriptor_81dfd49b5b303fb4, []int{11}
}

func (m *Kubernetes) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Kubernetes.Unmarshal(m, b)
}
func (m *Kubernetes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Kubernetes.Marshal(b, m, deterministic)
}
func (m *Kubernetes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Kubernetes.Merge(m, src)
}
func (m *Kubernetes) XXX_Size() int {
	return xxx_messageInfo_Kubernetes.Size(m)
}
func (m *Kubernetes) XXX_DiscardUnknown() {
	xxx_messageInfo_Kubernetes.DiscardUnknown(m)
}

var xxx_messageInfo_Kubernetes proto.InternalMessageInfo

func (m *Kubernetes) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Kubernetes) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Kubernetes) GetHealthy() bool {
	if m != nil {
		return m.Healthy
	}
	return false
}

func (m *Kubernetes) GetTags() []*Pair {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *Kubernetes) GetHostname() string {
	if m != nil {
		return m.Hostname
	}
	return ""
}

func (m *Kubernetes) GetPort() int32 {
	if m != nil {
		return m.Port
	}
	return 0
}

func (m *Kubernetes) GetCertificateAuthority() string {
	if m != nil {
		return m.CertificateAuthority
	}
	return ""
}

func (m *Kubernetes) GetCertificateAuthorityFilename() string {
	if m != nil {
		return m.CertificateAuthorityFilename
	}
	return ""
}

func (m *Kubernetes) GetClientCertificate() string {
	if m != nil {
		return m.ClientCertificate
	}
	return ""
}

func (m *Kubernetes) GetClientCertificateFilename() string {
	if m != nil {
		return m.ClientCertificateFilename
	}
	return ""
}

func (m *Kubernetes) GetClientKey() string {
	if m != nil {
		return m.ClientKey
	}
	return ""
}

func (m *Kubernetes) GetClientKeyFilename() string {
	if m != nil {
		return m.ClientKeyFilename
	}
	return ""
}

type KubernetesBasicAuth struct {
	// Unique identifier of the Resource.
	Id string `protobuf:"bytes,32768,opt,name=id,proto3" json:"id,omitempty"`
	// Unique human-readable name of the Resource.
	Name string `protobuf:"bytes,32769,opt,name=name,proto3" json:"name,omitempty"`
	// True if the datasource is reachable and the credentials are valid.
	Healthy bool `protobuf:"varint,32770,opt,name=healthy,proto3" json:"healthy,omitempty"`
	// Tags is a map of key, value pairs.
	Tags                 []*Pair  `protobuf:"bytes,32771,rep,name=tags,proto3" json:"tags,omitempty"`
	Hostname             string   `protobuf:"bytes,1,opt,name=hostname,proto3" json:"hostname,omitempty"`
	Port                 int32    `protobuf:"varint,2,opt,name=port,proto3" json:"port,omitempty"`
	Username             string   `protobuf:"bytes,3,opt,name=username,proto3" json:"username,omitempty"`
	Password             string   `protobuf:"bytes,4,opt,name=password,proto3" json:"password,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *KubernetesBasicAuth) Reset()         { *m = KubernetesBasicAuth{} }
func (m *KubernetesBasicAuth) String() string { return proto.CompactTextString(m) }
func (*KubernetesBasicAuth) ProtoMessage()    {}
func (*KubernetesBasicAuth) Descriptor() ([]byte, []int) {
	return fileDescriptor_81dfd49b5b303fb4, []int{12}
}

func (m *KubernetesBasicAuth) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_KubernetesBasicAuth.Unmarshal(m, b)
}
func (m *KubernetesBasicAuth) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_KubernetesBasicAuth.Marshal(b, m, deterministic)
}
func (m *KubernetesBasicAuth) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KubernetesBasicAuth.Merge(m, src)
}
func (m *KubernetesBasicAuth) XXX_Size() int {
	return xxx_messageInfo_KubernetesBasicAuth.Size(m)
}
func (m *KubernetesBasicAuth) XXX_DiscardUnknown() {
	xxx_messageInfo_KubernetesBasicAuth.DiscardUnknown(m)
}

var xxx_messageInfo_KubernetesBasicAuth proto.InternalMessageInfo

func (m *KubernetesBasicAuth) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *KubernetesBasicAuth) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *KubernetesBasicAuth) GetHealthy() bool {
	if m != nil {
		return m.Healthy
	}
	return false
}

func (m *KubernetesBasicAuth) GetTags() []*Pair {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *KubernetesBasicAuth) GetHostname() string {
	if m != nil {
		return m.Hostname
	}
	return ""
}

func (m *KubernetesBasicAuth) GetPort() int32 {
	if m != nil {
		return m.Port
	}
	return 0
}

func (m *KubernetesBasicAuth) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *KubernetesBasicAuth) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

type KubernetesServiceAccount struct {
	// Unique identifier of the Resource.
	Id string `protobuf:"bytes,32768,opt,name=id,proto3" json:"id,omitempty"`
	// Unique human-readable name of the Resource.
	Name string `protobuf:"bytes,32769,opt,name=name,proto3" json:"name,omitempty"`
	// True if the datasource is reachable and the credentials are valid.
	Healthy bool `protobuf:"varint,32770,opt,name=healthy,proto3" json:"healthy,omitempty"`
	// Tags is a map of key, value pairs.
	Tags                 []*Pair  `protobuf:"bytes,32771,rep,name=tags,proto3" json:"tags,omitempty"`
	Hostname             string   `protobuf:"bytes,1,opt,name=hostname,proto3" json:"hostname,omitempty"`
	Port                 int32    `protobuf:"varint,2,opt,name=port,proto3" json:"port,omitempty"`
	Token                string   `protobuf:"bytes,3,opt,name=token,proto3" json:"token,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *KubernetesServiceAccount) Reset()         { *m = KubernetesServiceAccount{} }
func (m *KubernetesServiceAccount) String() string { return proto.CompactTextString(m) }
func (*KubernetesServiceAccount) ProtoMessage()    {}
func (*KubernetesServiceAccount) Descriptor() ([]byte, []int) {
	return fileDescriptor_81dfd49b5b303fb4, []int{13}
}

func (m *KubernetesServiceAccount) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_KubernetesServiceAccount.Unmarshal(m, b)
}
func (m *KubernetesServiceAccount) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_KubernetesServiceAccount.Marshal(b, m, deterministic)
}
func (m *KubernetesServiceAccount) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KubernetesServiceAccount.Merge(m, src)
}
func (m *KubernetesServiceAccount) XXX_Size() int {
	return xxx_messageInfo_KubernetesServiceAccount.Size(m)
}
func (m *KubernetesServiceAccount) XXX_DiscardUnknown() {
	xxx_messageInfo_KubernetesServiceAccount.DiscardUnknown(m)
}

var xxx_messageInfo_KubernetesServiceAccount proto.InternalMessageInfo

func (m *KubernetesServiceAccount) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *KubernetesServiceAccount) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *KubernetesServiceAccount) GetHealthy() bool {
	if m != nil {
		return m.Healthy
	}
	return false
}

func (m *KubernetesServiceAccount) GetTags() []*Pair {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *KubernetesServiceAccount) GetHostname() string {
	if m != nil {
		return m.Hostname
	}
	return ""
}

func (m *KubernetesServiceAccount) GetPort() int32 {
	if m != nil {
		return m.Port
	}
	return 0
}

func (m *KubernetesServiceAccount) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

type AmazonEKS struct {
	// Unique identifier of the Resource.
	Id string `protobuf:"bytes,32768,opt,name=id,proto3" json:"id,omitempty"`
	// Unique human-readable name of the Resource.
	Name string `protobuf:"bytes,32769,opt,name=name,proto3" json:"name,omitempty"`
	// True if the datasource is reachable and the credentials are valid.
	Healthy bool `protobuf:"varint,32770,opt,name=healthy,proto3" json:"healthy,omitempty"`
	// Tags is a map of key, value pairs.
	Tags                         []*Pair  `protobuf:"bytes,32771,rep,name=tags,proto3" json:"tags,omitempty"`
	Endpoint                     string   `protobuf:"bytes,1,opt,name=endpoint,proto3" json:"endpoint,omitempty"`
	AccessKey                    string   `protobuf:"bytes,2,opt,name=access_key,json=accessKey,proto3" json:"access_key,omitempty"`
	SecretAccessKey              string   `protobuf:"bytes,3,opt,name=secret_access_key,json=secretAccessKey,proto3" json:"secret_access_key,omitempty"`
	CertificateAuthority         string   `protobuf:"bytes,4,opt,name=certificate_authority,json=certificateAuthority,proto3" json:"certificate_authority,omitempty"`
	CertificateAuthorityFilename string   `protobuf:"bytes,5,opt,name=certificate_authority_filename,json=certificateAuthorityFilename,proto3" json:"certificate_authority_filename,omitempty"`
	Region                       string   `protobuf:"bytes,6,opt,name=region,proto3" json:"region,omitempty"`
	ClusterName                  string   `protobuf:"bytes,7,opt,name=cluster_name,json=clusterName,proto3" json:"cluster_name,omitempty"`
	XXX_NoUnkeyedLiteral         struct{} `json:"-"`
	XXX_unrecognized             []byte   `json:"-"`
	XXX_sizecache                int32    `json:"-"`
}

func (m *AmazonEKS) Reset()         { *m = AmazonEKS{} }
func (m *AmazonEKS) String() string { return proto.CompactTextString(m) }
func (*AmazonEKS) ProtoMessage()    {}
func (*AmazonEKS) Descriptor() ([]byte, []int) {
	return fileDescriptor_81dfd49b5b303fb4, []int{14}
}

func (m *AmazonEKS) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AmazonEKS.Unmarshal(m, b)
}
func (m *AmazonEKS) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AmazonEKS.Marshal(b, m, deterministic)
}
func (m *AmazonEKS) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AmazonEKS.Merge(m, src)
}
func (m *AmazonEKS) XXX_Size() int {
	return xxx_messageInfo_AmazonEKS.Size(m)
}
func (m *AmazonEKS) XXX_DiscardUnknown() {
	xxx_messageInfo_AmazonEKS.DiscardUnknown(m)
}

var xxx_messageInfo_AmazonEKS proto.InternalMessageInfo

func (m *AmazonEKS) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *AmazonEKS) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *AmazonEKS) GetHealthy() bool {
	if m != nil {
		return m.Healthy
	}
	return false
}

func (m *AmazonEKS) GetTags() []*Pair {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *AmazonEKS) GetEndpoint() string {
	if m != nil {
		return m.Endpoint
	}
	return ""
}

func (m *AmazonEKS) GetAccessKey() string {
	if m != nil {
		return m.AccessKey
	}
	return ""
}

func (m *AmazonEKS) GetSecretAccessKey() string {
	if m != nil {
		return m.SecretAccessKey
	}
	return ""
}

func (m *AmazonEKS) GetCertificateAuthority() string {
	if m != nil {
		return m.CertificateAuthority
	}
	return ""
}

func (m *AmazonEKS) GetCertificateAuthorityFilename() string {
	if m != nil {
		return m.CertificateAuthorityFilename
	}
	return ""
}

func (m *AmazonEKS) GetRegion() string {
	if m != nil {
		return m.Region
	}
	return ""
}

func (m *AmazonEKS) GetClusterName() string {
	if m != nil {
		return m.ClusterName
	}
	return ""
}

type GoogleGKE struct {
	// Unique identifier of the Resource.
	Id string `protobuf:"bytes,32768,opt,name=id,proto3" json:"id,omitempty"`
	// Unique human-readable name of the Resource.
	Name string `protobuf:"bytes,32769,opt,name=name,proto3" json:"name,omitempty"`
	// True if the datasource is reachable and the credentials are valid.
	Healthy bool `protobuf:"varint,32770,opt,name=healthy,proto3" json:"healthy,omitempty"`
	// Tags is a map of key, value pairs.
	Tags                         []*Pair  `protobuf:"bytes,32771,rep,name=tags,proto3" json:"tags,omitempty"`
	Endpoint                     string   `protobuf:"bytes,1,opt,name=endpoint,proto3" json:"endpoint,omitempty"`
	CertificateAuthority         string   `protobuf:"bytes,2,opt,name=certificate_authority,json=certificateAuthority,proto3" json:"certificate_authority,omitempty"`
	CertificateAuthorityFilename string   `protobuf:"bytes,3,opt,name=certificate_authority_filename,json=certificateAuthorityFilename,proto3" json:"certificate_authority_filename,omitempty"`
	ServiceAccountKey            string   `protobuf:"bytes,4,opt,name=service_account_key,json=serviceAccountKey,proto3" json:"service_account_key,omitempty"`
	ServiceAccountKeyFilename    string   `protobuf:"bytes,5,opt,name=service_account_key_filename,json=serviceAccountKeyFilename,proto3" json:"service_account_key_filename,omitempty"`
	XXX_NoUnkeyedLiteral         struct{} `json:"-"`
	XXX_unrecognized             []byte   `json:"-"`
	XXX_sizecache                int32    `json:"-"`
}

func (m *GoogleGKE) Reset()         { *m = GoogleGKE{} }
func (m *GoogleGKE) String() string { return proto.CompactTextString(m) }
func (*GoogleGKE) ProtoMessage()    {}
func (*GoogleGKE) Descriptor() ([]byte, []int) {
	return fileDescriptor_81dfd49b5b303fb4, []int{15}
}

func (m *GoogleGKE) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GoogleGKE.Unmarshal(m, b)
}
func (m *GoogleGKE) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GoogleGKE.Marshal(b, m, deterministic)
}
func (m *GoogleGKE) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GoogleGKE.Merge(m, src)
}
func (m *GoogleGKE) XXX_Size() int {
	return xxx_messageInfo_GoogleGKE.Size(m)
}
func (m *GoogleGKE) XXX_DiscardUnknown() {
	xxx_messageInfo_GoogleGKE.DiscardUnknown(m)
}

var xxx_messageInfo_GoogleGKE proto.InternalMessageInfo

func (m *GoogleGKE) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *GoogleGKE) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *GoogleGKE) GetHealthy() bool {
	if m != nil {
		return m.Healthy
	}
	return false
}

func (m *GoogleGKE) GetTags() []*Pair {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *GoogleGKE) GetEndpoint() string {
	if m != nil {
		return m.Endpoint
	}
	return ""
}

func (m *GoogleGKE) GetCertificateAuthority() string {
	if m != nil {
		return m.CertificateAuthority
	}
	return ""
}

func (m *GoogleGKE) GetCertificateAuthorityFilename() string {
	if m != nil {
		return m.CertificateAuthorityFilename
	}
	return ""
}

func (m *GoogleGKE) GetServiceAccountKey() string {
	if m != nil {
		return m.ServiceAccountKey
	}
	return ""
}

func (m *GoogleGKE) GetServiceAccountKeyFilename() string {
	if m != nil {
		return m.ServiceAccountKeyFilename
	}
	return ""
}

type AKS struct {
	// Unique identifier of the Resource.
	Id string `protobuf:"bytes,32768,opt,name=id,proto3" json:"id,omitempty"`
	// Unique human-readable name of the Resource.
	Name string `protobuf:"bytes,32769,opt,name=name,proto3" json:"name,omitempty"`
	// True if the datasource is reachable and the credentials are valid.
	Healthy bool `protobuf:"varint,32770,opt,name=healthy,proto3" json:"healthy,omitempty"`
	// Tags is a map of key, value pairs.
	Tags                         []*Pair  `protobuf:"bytes,32771,rep,name=tags,proto3" json:"tags,omitempty"`
	Hostname                     string   `protobuf:"bytes,1,opt,name=hostname,proto3" json:"hostname,omitempty"`
	Port                         int32    `protobuf:"varint,2,opt,name=port,proto3" json:"port,omitempty"`
	CertificateAuthority         string   `protobuf:"bytes,3,opt,name=certificate_authority,json=certificateAuthority,proto3" json:"certificate_authority,omitempty"`
	CertificateAuthorityFilename string   `protobuf:"bytes,4,opt,name=certificate_authority_filename,json=certificateAuthorityFilename,proto3" json:"certificate_authority_filename,omitempty"`
	ClientCertificate            string   `protobuf:"bytes,5,opt,name=client_certificate,json=clientCertificate,proto3" json:"client_certificate,omitempty"`
	ClientCertificateFilename    string   `protobuf:"bytes,6,opt,name=client_certificate_filename,json=clientCertificateFilename,proto3" json:"client_certificate_filename,omitempty"`
	ClientKey                    string   `protobuf:"bytes,7,opt,name=client_key,json=clientKey,proto3" json:"client_key,omitempty"`
	ClientKeyFilename            string   `protobuf:"bytes,8,opt,name=client_key_filename,json=clientKeyFilename,proto3" json:"client_key_filename,omitempty"`
	XXX_NoUnkeyedLiteral         struct{} `json:"-"`
	XXX_unrecognized             []byte   `json:"-"`
	XXX_sizecache                int32    `json:"-"`
}

func (m *AKS) Reset()         { *m = AKS{} }
func (m *AKS) String() string { return proto.CompactTextString(m) }
func (*AKS) ProtoMessage()    {}
func (*AKS) Descriptor() ([]byte, []int) {
	return fileDescriptor_81dfd49b5b303fb4, []int{16}
}

func (m *AKS) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AKS.Unmarshal(m, b)
}
func (m *AKS) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AKS.Marshal(b, m, deterministic)
}
func (m *AKS) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AKS.Merge(m, src)
}
func (m *AKS) XXX_Size() int {
	return xxx_messageInfo_AKS.Size(m)
}
func (m *AKS) XXX_DiscardUnknown() {
	xxx_messageInfo_AKS.DiscardUnknown(m)
}

var xxx_messageInfo_AKS proto.InternalMessageInfo

func (m *AKS) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *AKS) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *AKS) GetHealthy() bool {
	if m != nil {
		return m.Healthy
	}
	return false
}

func (m *AKS) GetTags() []*Pair {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *AKS) GetHostname() string {
	if m != nil {
		return m.Hostname
	}
	return ""
}

func (m *AKS) GetPort() int32 {
	if m != nil {
		return m.Port
	}
	return 0
}

func (m *AKS) GetCertificateAuthority() string {
	if m != nil {
		return m.CertificateAuthority
	}
	return ""
}

func (m *AKS) GetCertificateAuthorityFilename() string {
	if m != nil {
		return m.CertificateAuthorityFilename
	}
	return ""
}

func (m *AKS) GetClientCertificate() string {
	if m != nil {
		return m.ClientCertificate
	}
	return ""
}

func (m *AKS) GetClientCertificateFilename() string {
	if m != nil {
		return m.ClientCertificateFilename
	}
	return ""
}

func (m *AKS) GetClientKey() string {
	if m != nil {
		return m.ClientKey
	}
	return ""
}

func (m *AKS) GetClientKeyFilename() string {
	if m != nil {
		return m.ClientKeyFilename
	}
	return ""
}

type AKSBasicAuth struct {
	// Unique identifier of the Resource.
	Id string `protobuf:"bytes,32768,opt,name=id,proto3" json:"id,omitempty"`
	// Unique human-readable name of the Resource.
	Name string `protobuf:"bytes,32769,opt,name=name,proto3" json:"name,omitempty"`
	// True if the datasource is reachable and the credentials are valid.
	Healthy bool `protobuf:"varint,32770,opt,name=healthy,proto3" json:"healthy,omitempty"`
	// Tags is a map of key, value pairs.
	Tags                 []*Pair  `protobuf:"bytes,32771,rep,name=tags,proto3" json:"tags,omitempty"`
	Hostname             string   `protobuf:"bytes,1,opt,name=hostname,proto3" json:"hostname,omitempty"`
	Port                 int32    `protobuf:"varint,2,opt,name=port,proto3" json:"port,omitempty"`
	Username             string   `protobuf:"bytes,3,opt,name=username,proto3" json:"username,omitempty"`
	Password             string   `protobuf:"bytes,4,opt,name=password,proto3" json:"password,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AKSBasicAuth) Reset()         { *m = AKSBasicAuth{} }
func (m *AKSBasicAuth) String() string { return proto.CompactTextString(m) }
func (*AKSBasicAuth) ProtoMessage()    {}
func (*AKSBasicAuth) Descriptor() ([]byte, []int) {
	return fileDescriptor_81dfd49b5b303fb4, []int{17}
}

func (m *AKSBasicAuth) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AKSBasicAuth.Unmarshal(m, b)
}
func (m *AKSBasicAuth) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AKSBasicAuth.Marshal(b, m, deterministic)
}
func (m *AKSBasicAuth) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AKSBasicAuth.Merge(m, src)
}
func (m *AKSBasicAuth) XXX_Size() int {
	return xxx_messageInfo_AKSBasicAuth.Size(m)
}
func (m *AKSBasicAuth) XXX_DiscardUnknown() {
	xxx_messageInfo_AKSBasicAuth.DiscardUnknown(m)
}

var xxx_messageInfo_AKSBasicAuth proto.InternalMessageInfo

func (m *AKSBasicAuth) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *AKSBasicAuth) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *AKSBasicAuth) GetHealthy() bool {
	if m != nil {
		return m.Healthy
	}
	return false
}

func (m *AKSBasicAuth) GetTags() []*Pair {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *AKSBasicAuth) GetHostname() string {
	if m != nil {
		return m.Hostname
	}
	return ""
}

func (m *AKSBasicAuth) GetPort() int32 {
	if m != nil {
		return m.Port
	}
	return 0
}

func (m *AKSBasicAuth) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *AKSBasicAuth) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

type AKSServiceAccount struct {
	// Unique identifier of the Resource.
	Id string `protobuf:"bytes,32768,opt,name=id,proto3" json:"id,omitempty"`
	// Unique human-readable name of the Resource.
	Name string `protobuf:"bytes,32769,opt,name=name,proto3" json:"name,omitempty"`
	// True if the datasource is reachable and the credentials are valid.
	Healthy bool `protobuf:"varint,32770,opt,name=healthy,proto3" json:"healthy,omitempty"`
	// Tags is a map of key, value pairs.
	Tags                 []*Pair  `protobuf:"bytes,32771,rep,name=tags,proto3" json:"tags,omitempty"`
	Hostname             string   `protobuf:"bytes,1,opt,name=hostname,proto3" json:"hostname,omitempty"`
	Port                 int32    `protobuf:"varint,2,opt,name=port,proto3" json:"port,omitempty"`
	Token                string   `protobuf:"bytes,3,opt,name=token,proto3" json:"token,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AKSServiceAccount) Reset()         { *m = AKSServiceAccount{} }
func (m *AKSServiceAccount) String() string { return proto.CompactTextString(m) }
func (*AKSServiceAccount) ProtoMessage()    {}
func (*AKSServiceAccount) Descriptor() ([]byte, []int) {
	return fileDescriptor_81dfd49b5b303fb4, []int{18}
}

func (m *AKSServiceAccount) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AKSServiceAccount.Unmarshal(m, b)
}
func (m *AKSServiceAccount) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AKSServiceAccount.Marshal(b, m, deterministic)
}
func (m *AKSServiceAccount) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AKSServiceAccount.Merge(m, src)
}
func (m *AKSServiceAccount) XXX_Size() int {
	return xxx_messageInfo_AKSServiceAccount.Size(m)
}
func (m *AKSServiceAccount) XXX_DiscardUnknown() {
	xxx_messageInfo_AKSServiceAccount.DiscardUnknown(m)
}

var xxx_messageInfo_AKSServiceAccount proto.InternalMessageInfo

func (m *AKSServiceAccount) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *AKSServiceAccount) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *AKSServiceAccount) GetHealthy() bool {
	if m != nil {
		return m.Healthy
	}
	return false
}

func (m *AKSServiceAccount) GetTags() []*Pair {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *AKSServiceAccount) GetHostname() string {
	if m != nil {
		return m.Hostname
	}
	return ""
}

func (m *AKSServiceAccount) GetPort() int32 {
	if m != nil {
		return m.Port
	}
	return 0
}

func (m *AKSServiceAccount) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

type Memcached struct {
	// Unique identifier of the Resource.
	Id string `protobuf:"bytes,32768,opt,name=id,proto3" json:"id,omitempty"`
	// Unique human-readable name of the Resource.
	Name string `protobuf:"bytes,32769,opt,name=name,proto3" json:"name,omitempty"`
	// True if the datasource is reachable and the credentials are valid.
	Healthy bool `protobuf:"varint,32770,opt,name=healthy,proto3" json:"healthy,omitempty"`
	// Tags is a map of key, value pairs.
	Tags                 []*Pair  `protobuf:"bytes,32771,rep,name=tags,proto3" json:"tags,omitempty"`
	Hostname             string   `protobuf:"bytes,1,opt,name=hostname,proto3" json:"hostname,omitempty"`
	PortOverride         int32    `protobuf:"varint,2,opt,name=port_override,json=portOverride,proto3" json:"port_override,omitempty"`
	Port                 int32    `protobuf:"varint,3,opt,name=port,proto3" json:"port,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Memcached) Reset()         { *m = Memcached{} }
func (m *Memcached) String() string { return proto.CompactTextString(m) }
func (*Memcached) ProtoMessage()    {}
func (*Memcached) Descriptor() ([]byte, []int) {
	return fileDescriptor_81dfd49b5b303fb4, []int{19}
}

func (m *Memcached) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Memcached.Unmarshal(m, b)
}
func (m *Memcached) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Memcached.Marshal(b, m, deterministic)
}
func (m *Memcached) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Memcached.Merge(m, src)
}
func (m *Memcached) XXX_Size() int {
	return xxx_messageInfo_Memcached.Size(m)
}
func (m *Memcached) XXX_DiscardUnknown() {
	xxx_messageInfo_Memcached.DiscardUnknown(m)
}

var xxx_messageInfo_Memcached proto.InternalMessageInfo

func (m *Memcached) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Memcached) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Memcached) GetHealthy() bool {
	if m != nil {
		return m.Healthy
	}
	return false
}

func (m *Memcached) GetTags() []*Pair {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *Memcached) GetHostname() string {
	if m != nil {
		return m.Hostname
	}
	return ""
}

func (m *Memcached) GetPortOverride() int32 {
	if m != nil {
		return m.PortOverride
	}
	return 0
}

func (m *Memcached) GetPort() int32 {
	if m != nil {
		return m.Port
	}
	return 0
}

type MongoLegacyHost struct {
	// Unique identifier of the Resource.
	Id string `protobuf:"bytes,32768,opt,name=id,proto3" json:"id,omitempty"`
	// Unique human-readable name of the Resource.
	Name string `protobuf:"bytes,32769,opt,name=name,proto3" json:"name,omitempty"`
	// True if the datasource is reachable and the credentials are valid.
	Healthy bool `protobuf:"varint,32770,opt,name=healthy,proto3" json:"healthy,omitempty"`
	// Tags is a map of key, value pairs.
	Tags                 []*Pair  `protobuf:"bytes,32771,rep,name=tags,proto3" json:"tags,omitempty"`
	Hostname             string   `protobuf:"bytes,1,opt,name=hostname,proto3" json:"hostname,omitempty"`
	AuthDatabase         string   `protobuf:"bytes,2,opt,name=auth_database,json=authDatabase,proto3" json:"auth_database,omitempty"`
	PortOverride         int32    `protobuf:"varint,3,opt,name=port_override,json=portOverride,proto3" json:"port_override,omitempty"`
	Username             string   `protobuf:"bytes,4,opt,name=username,proto3" json:"username,omitempty"`
	Password             string   `protobuf:"bytes,5,opt,name=password,proto3" json:"password,omitempty"`
	Port                 int32    `protobuf:"varint,6,opt,name=port,proto3" json:"port,omitempty"`
	ReplicaSet           string   `protobuf:"bytes,7,opt,name=replica_set,json=replicaSet,proto3" json:"replica_set,omitempty"`
	TlsRequired          bool     `protobuf:"varint,8,opt,name=tls_required,json=tlsRequired,proto3" json:"tls_required,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MongoLegacyHost) Reset()         { *m = MongoLegacyHost{} }
func (m *MongoLegacyHost) String() string { return proto.CompactTextString(m) }
func (*MongoLegacyHost) ProtoMessage()    {}
func (*MongoLegacyHost) Descriptor() ([]byte, []int) {
	return fileDescriptor_81dfd49b5b303fb4, []int{20}
}

func (m *MongoLegacyHost) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_MongoLegacyHost.Unmarshal(m, b)
}
func (m *MongoLegacyHost) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_MongoLegacyHost.Marshal(b, m, deterministic)
}
func (m *MongoLegacyHost) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MongoLegacyHost.Merge(m, src)
}
func (m *MongoLegacyHost) XXX_Size() int {
	return xxx_messageInfo_MongoLegacyHost.Size(m)
}
func (m *MongoLegacyHost) XXX_DiscardUnknown() {
	xxx_messageInfo_MongoLegacyHost.DiscardUnknown(m)
}

var xxx_messageInfo_MongoLegacyHost proto.InternalMessageInfo

func (m *MongoLegacyHost) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *MongoLegacyHost) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *MongoLegacyHost) GetHealthy() bool {
	if m != nil {
		return m.Healthy
	}
	return false
}

func (m *MongoLegacyHost) GetTags() []*Pair {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *MongoLegacyHost) GetHostname() string {
	if m != nil {
		return m.Hostname
	}
	return ""
}

func (m *MongoLegacyHost) GetAuthDatabase() string {
	if m != nil {
		return m.AuthDatabase
	}
	return ""
}

func (m *MongoLegacyHost) GetPortOverride() int32 {
	if m != nil {
		return m.PortOverride
	}
	return 0
}

func (m *MongoLegacyHost) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *MongoLegacyHost) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

func (m *MongoLegacyHost) GetPort() int32 {
	if m != nil {
		return m.Port
	}
	return 0
}

func (m *MongoLegacyHost) GetReplicaSet() string {
	if m != nil {
		return m.ReplicaSet
	}
	return ""
}

func (m *MongoLegacyHost) GetTlsRequired() bool {
	if m != nil {
		return m.TlsRequired
	}
	return false
}

type MongoLegacyReplicaset struct {
	// Unique identifier of the Resource.
	Id string `protobuf:"bytes,32768,opt,name=id,proto3" json:"id,omitempty"`
	// Unique human-readable name of the Resource.
	Name string `protobuf:"bytes,32769,opt,name=name,proto3" json:"name,omitempty"`
	// True if the datasource is reachable and the credentials are valid.
	Healthy bool `protobuf:"varint,32770,opt,name=healthy,proto3" json:"healthy,omitempty"`
	// Tags is a map of key, value pairs.
	Tags                 []*Pair  `protobuf:"bytes,32771,rep,name=tags,proto3" json:"tags,omitempty"`
	Hostname             string   `protobuf:"bytes,1,opt,name=hostname,proto3" json:"hostname,omitempty"`
	AuthDatabase         string   `protobuf:"bytes,2,opt,name=auth_database,json=authDatabase,proto3" json:"auth_database,omitempty"`
	PortOverride         int32    `protobuf:"varint,3,opt,name=port_override,json=portOverride,proto3" json:"port_override,omitempty"`
	Username             string   `protobuf:"bytes,4,opt,name=username,proto3" json:"username,omitempty"`
	Password             string   `protobuf:"bytes,5,opt,name=password,proto3" json:"password,omitempty"`
	Port                 int32    `protobuf:"varint,6,opt,name=port,proto3" json:"port,omitempty"`
	ReplicaSet           string   `protobuf:"bytes,7,opt,name=replica_set,json=replicaSet,proto3" json:"replica_set,omitempty"`
	ConnectToReplica     bool     `protobuf:"varint,8,opt,name=connect_to_replica,json=connectToReplica,proto3" json:"connect_to_replica,omitempty"`
	TlsRequired          bool     `protobuf:"varint,9,opt,name=tls_required,json=tlsRequired,proto3" json:"tls_required,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MongoLegacyReplicaset) Reset()         { *m = MongoLegacyReplicaset{} }
func (m *MongoLegacyReplicaset) String() string { return proto.CompactTextString(m) }
func (*MongoLegacyReplicaset) ProtoMessage()    {}
func (*MongoLegacyReplicaset) Descriptor() ([]byte, []int) {
	return fileDescriptor_81dfd49b5b303fb4, []int{21}
}

func (m *MongoLegacyReplicaset) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_MongoLegacyReplicaset.Unmarshal(m, b)
}
func (m *MongoLegacyReplicaset) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_MongoLegacyReplicaset.Marshal(b, m, deterministic)
}
func (m *MongoLegacyReplicaset) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MongoLegacyReplicaset.Merge(m, src)
}
func (m *MongoLegacyReplicaset) XXX_Size() int {
	return xxx_messageInfo_MongoLegacyReplicaset.Size(m)
}
func (m *MongoLegacyReplicaset) XXX_DiscardUnknown() {
	xxx_messageInfo_MongoLegacyReplicaset.DiscardUnknown(m)
}

var xxx_messageInfo_MongoLegacyReplicaset proto.InternalMessageInfo

func (m *MongoLegacyReplicaset) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *MongoLegacyReplicaset) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *MongoLegacyReplicaset) GetHealthy() bool {
	if m != nil {
		return m.Healthy
	}
	return false
}

func (m *MongoLegacyReplicaset) GetTags() []*Pair {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *MongoLegacyReplicaset) GetHostname() string {
	if m != nil {
		return m.Hostname
	}
	return ""
}

func (m *MongoLegacyReplicaset) GetAuthDatabase() string {
	if m != nil {
		return m.AuthDatabase
	}
	return ""
}

func (m *MongoLegacyReplicaset) GetPortOverride() int32 {
	if m != nil {
		return m.PortOverride
	}
	return 0
}

func (m *MongoLegacyReplicaset) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *MongoLegacyReplicaset) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

func (m *MongoLegacyReplicaset) GetPort() int32 {
	if m != nil {
		return m.Port
	}
	return 0
}

func (m *MongoLegacyReplicaset) GetReplicaSet() string {
	if m != nil {
		return m.ReplicaSet
	}
	return ""
}

func (m *MongoLegacyReplicaset) GetConnectToReplica() bool {
	if m != nil {
		return m.ConnectToReplica
	}
	return false
}

func (m *MongoLegacyReplicaset) GetTlsRequired() bool {
	if m != nil {
		return m.TlsRequired
	}
	return false
}

type MongoHost struct {
	// Unique identifier of the Resource.
	Id string `protobuf:"bytes,32768,opt,name=id,proto3" json:"id,omitempty"`
	// Unique human-readable name of the Resource.
	Name string `protobuf:"bytes,32769,opt,name=name,proto3" json:"name,omitempty"`
	// True if the datasource is reachable and the credentials are valid.
	Healthy bool `protobuf:"varint,32770,opt,name=healthy,proto3" json:"healthy,omitempty"`
	// Tags is a map of key, value pairs.
	Tags                 []*Pair  `protobuf:"bytes,32771,rep,name=tags,proto3" json:"tags,omitempty"`
	Hostname             string   `protobuf:"bytes,1,opt,name=hostname,proto3" json:"hostname,omitempty"`
	AuthDatabase         string   `protobuf:"bytes,2,opt,name=auth_database,json=authDatabase,proto3" json:"auth_database,omitempty"`
	PortOverride         int32    `protobuf:"varint,3,opt,name=port_override,json=portOverride,proto3" json:"port_override,omitempty"`
	Username             string   `protobuf:"bytes,4,opt,name=username,proto3" json:"username,omitempty"`
	Password             string   `protobuf:"bytes,5,opt,name=password,proto3" json:"password,omitempty"`
	Port                 int32    `protobuf:"varint,6,opt,name=port,proto3" json:"port,omitempty"`
	TlsRequired          bool     `protobuf:"varint,8,opt,name=tls_required,json=tlsRequired,proto3" json:"tls_required,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MongoHost) Reset()         { *m = MongoHost{} }
func (m *MongoHost) String() string { return proto.CompactTextString(m) }
func (*MongoHost) ProtoMessage()    {}
func (*MongoHost) Descriptor() ([]byte, []int) {
	return fileDescriptor_81dfd49b5b303fb4, []int{22}
}

func (m *MongoHost) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_MongoHost.Unmarshal(m, b)
}
func (m *MongoHost) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_MongoHost.Marshal(b, m, deterministic)
}
func (m *MongoHost) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MongoHost.Merge(m, src)
}
func (m *MongoHost) XXX_Size() int {
	return xxx_messageInfo_MongoHost.Size(m)
}
func (m *MongoHost) XXX_DiscardUnknown() {
	xxx_messageInfo_MongoHost.DiscardUnknown(m)
}

var xxx_messageInfo_MongoHost proto.InternalMessageInfo

func (m *MongoHost) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *MongoHost) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *MongoHost) GetHealthy() bool {
	if m != nil {
		return m.Healthy
	}
	return false
}

func (m *MongoHost) GetTags() []*Pair {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *MongoHost) GetHostname() string {
	if m != nil {
		return m.Hostname
	}
	return ""
}

func (m *MongoHost) GetAuthDatabase() string {
	if m != nil {
		return m.AuthDatabase
	}
	return ""
}

func (m *MongoHost) GetPortOverride() int32 {
	if m != nil {
		return m.PortOverride
	}
	return 0
}

func (m *MongoHost) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *MongoHost) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

func (m *MongoHost) GetPort() int32 {
	if m != nil {
		return m.Port
	}
	return 0
}

func (m *MongoHost) GetTlsRequired() bool {
	if m != nil {
		return m.TlsRequired
	}
	return false
}

type MongoReplicaSet struct {
	// Unique identifier of the Resource.
	Id string `protobuf:"bytes,32768,opt,name=id,proto3" json:"id,omitempty"`
	// Unique human-readable name of the Resource.
	Name string `protobuf:"bytes,32769,opt,name=name,proto3" json:"name,omitempty"`
	// True if the datasource is reachable and the credentials are valid.
	Healthy bool `protobuf:"varint,32770,opt,name=healthy,proto3" json:"healthy,omitempty"`
	// Tags is a map of key, value pairs.
	Tags                 []*Pair  `protobuf:"bytes,32771,rep,name=tags,proto3" json:"tags,omitempty"`
	Hostname             string   `protobuf:"bytes,1,opt,name=hostname,proto3" json:"hostname,omitempty"`
	AuthDatabase         string   `protobuf:"bytes,2,opt,name=auth_database,json=authDatabase,proto3" json:"auth_database,omitempty"`
	PortOverride         int32    `protobuf:"varint,3,opt,name=port_override,json=portOverride,proto3" json:"port_override,omitempty"`
	Username             string   `protobuf:"bytes,4,opt,name=username,proto3" json:"username,omitempty"`
	Password             string   `protobuf:"bytes,5,opt,name=password,proto3" json:"password,omitempty"`
	Port                 int32    `protobuf:"varint,6,opt,name=port,proto3" json:"port,omitempty"`
	ReplicaSet           string   `protobuf:"bytes,7,opt,name=replica_set,json=replicaSet,proto3" json:"replica_set,omitempty"`
	ConnectToReplica     bool     `protobuf:"varint,8,opt,name=connect_to_replica,json=connectToReplica,proto3" json:"connect_to_replica,omitempty"`
	TlsRequired          bool     `protobuf:"varint,9,opt,name=tls_required,json=tlsRequired,proto3" json:"tls_required,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MongoReplicaSet) Reset()         { *m = MongoReplicaSet{} }
func (m *MongoReplicaSet) String() string { return proto.CompactTextString(m) }
func (*MongoReplicaSet) ProtoMessage()    {}
func (*MongoReplicaSet) Descriptor() ([]byte, []int) {
	return fileDescriptor_81dfd49b5b303fb4, []int{23}
}

func (m *MongoReplicaSet) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_MongoReplicaSet.Unmarshal(m, b)
}
func (m *MongoReplicaSet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_MongoReplicaSet.Marshal(b, m, deterministic)
}
func (m *MongoReplicaSet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MongoReplicaSet.Merge(m, src)
}
func (m *MongoReplicaSet) XXX_Size() int {
	return xxx_messageInfo_MongoReplicaSet.Size(m)
}
func (m *MongoReplicaSet) XXX_DiscardUnknown() {
	xxx_messageInfo_MongoReplicaSet.DiscardUnknown(m)
}

var xxx_messageInfo_MongoReplicaSet proto.InternalMessageInfo

func (m *MongoReplicaSet) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *MongoReplicaSet) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *MongoReplicaSet) GetHealthy() bool {
	if m != nil {
		return m.Healthy
	}
	return false
}

func (m *MongoReplicaSet) GetTags() []*Pair {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *MongoReplicaSet) GetHostname() string {
	if m != nil {
		return m.Hostname
	}
	return ""
}

func (m *MongoReplicaSet) GetAuthDatabase() string {
	if m != nil {
		return m.AuthDatabase
	}
	return ""
}

func (m *MongoReplicaSet) GetPortOverride() int32 {
	if m != nil {
		return m.PortOverride
	}
	return 0
}

func (m *MongoReplicaSet) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *MongoReplicaSet) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

func (m *MongoReplicaSet) GetPort() int32 {
	if m != nil {
		return m.Port
	}
	return 0
}

func (m *MongoReplicaSet) GetReplicaSet() string {
	if m != nil {
		return m.ReplicaSet
	}
	return ""
}

func (m *MongoReplicaSet) GetConnectToReplica() bool {
	if m != nil {
		return m.ConnectToReplica
	}
	return false
}

func (m *MongoReplicaSet) GetTlsRequired() bool {
	if m != nil {
		return m.TlsRequired
	}
	return false
}

type Mysql struct {
	// Unique identifier of the Resource.
	Id string `protobuf:"bytes,32768,opt,name=id,proto3" json:"id,omitempty"`
	// Unique human-readable name of the Resource.
	Name string `protobuf:"bytes,32769,opt,name=name,proto3" json:"name,omitempty"`
	// True if the datasource is reachable and the credentials are valid.
	Healthy bool `protobuf:"varint,32770,opt,name=healthy,proto3" json:"healthy,omitempty"`
	// Tags is a map of key, value pairs.
	Tags                 []*Pair  `protobuf:"bytes,32771,rep,name=tags,proto3" json:"tags,omitempty"`
	Hostname             string   `protobuf:"bytes,1,opt,name=hostname,proto3" json:"hostname,omitempty"`
	Username             string   `protobuf:"bytes,2,opt,name=username,proto3" json:"username,omitempty"`
	Password             string   `protobuf:"bytes,3,opt,name=password,proto3" json:"password,omitempty"`
	Database             string   `protobuf:"bytes,4,opt,name=database,proto3" json:"database,omitempty"`
	PortOverride         int32    `protobuf:"varint,5,opt,name=port_override,json=portOverride,proto3" json:"port_override,omitempty"`
	Port                 int32    `protobuf:"varint,6,opt,name=port,proto3" json:"port,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Mysql) Reset()         { *m = Mysql{} }
func (m *Mysql) String() string { return proto.CompactTextString(m) }
func (*Mysql) ProtoMessage()    {}
func (*Mysql) Descriptor() ([]byte, []int) {
	return fileDescriptor_81dfd49b5b303fb4, []int{24}
}

func (m *Mysql) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Mysql.Unmarshal(m, b)
}
func (m *Mysql) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Mysql.Marshal(b, m, deterministic)
}
func (m *Mysql) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Mysql.Merge(m, src)
}
func (m *Mysql) XXX_Size() int {
	return xxx_messageInfo_Mysql.Size(m)
}
func (m *Mysql) XXX_DiscardUnknown() {
	xxx_messageInfo_Mysql.DiscardUnknown(m)
}

var xxx_messageInfo_Mysql proto.InternalMessageInfo

func (m *Mysql) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Mysql) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Mysql) GetHealthy() bool {
	if m != nil {
		return m.Healthy
	}
	return false
}

func (m *Mysql) GetTags() []*Pair {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *Mysql) GetHostname() string {
	if m != nil {
		return m.Hostname
	}
	return ""
}

func (m *Mysql) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *Mysql) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

func (m *Mysql) GetDatabase() string {
	if m != nil {
		return m.Database
	}
	return ""
}

func (m *Mysql) GetPortOverride() int32 {
	if m != nil {
		return m.PortOverride
	}
	return 0
}

func (m *Mysql) GetPort() int32 {
	if m != nil {
		return m.Port
	}
	return 0
}

type AuroraMysql struct {
	// Unique identifier of the Resource.
	Id string `protobuf:"bytes,32768,opt,name=id,proto3" json:"id,omitempty"`
	// Unique human-readable name of the Resource.
	Name string `protobuf:"bytes,32769,opt,name=name,proto3" json:"name,omitempty"`
	// True if the datasource is reachable and the credentials are valid.
	Healthy bool `protobuf:"varint,32770,opt,name=healthy,proto3" json:"healthy,omitempty"`
	// Tags is a map of key, value pairs.
	Tags                 []*Pair  `protobuf:"bytes,32771,rep,name=tags,proto3" json:"tags,omitempty"`
	Hostname             string   `protobuf:"bytes,1,opt,name=hostname,proto3" json:"hostname,omitempty"`
	Username             string   `protobuf:"bytes,2,opt,name=username,proto3" json:"username,omitempty"`
	Password             string   `protobuf:"bytes,3,opt,name=password,proto3" json:"password,omitempty"`
	Database             string   `protobuf:"bytes,4,opt,name=database,proto3" json:"database,omitempty"`
	PortOverride         int32    `protobuf:"varint,5,opt,name=port_override,json=portOverride,proto3" json:"port_override,omitempty"`
	Port                 int32    `protobuf:"varint,6,opt,name=port,proto3" json:"port,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AuroraMysql) Reset()         { *m = AuroraMysql{} }
func (m *AuroraMysql) String() string { return proto.CompactTextString(m) }
func (*AuroraMysql) ProtoMessage()    {}
func (*AuroraMysql) Descriptor() ([]byte, []int) {
	return fileDescriptor_81dfd49b5b303fb4, []int{25}
}

func (m *AuroraMysql) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AuroraMysql.Unmarshal(m, b)
}
func (m *AuroraMysql) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AuroraMysql.Marshal(b, m, deterministic)
}
func (m *AuroraMysql) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AuroraMysql.Merge(m, src)
}
func (m *AuroraMysql) XXX_Size() int {
	return xxx_messageInfo_AuroraMysql.Size(m)
}
func (m *AuroraMysql) XXX_DiscardUnknown() {
	xxx_messageInfo_AuroraMysql.DiscardUnknown(m)
}

var xxx_messageInfo_AuroraMysql proto.InternalMessageInfo

func (m *AuroraMysql) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *AuroraMysql) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *AuroraMysql) GetHealthy() bool {
	if m != nil {
		return m.Healthy
	}
	return false
}

func (m *AuroraMysql) GetTags() []*Pair {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *AuroraMysql) GetHostname() string {
	if m != nil {
		return m.Hostname
	}
	return ""
}

func (m *AuroraMysql) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *AuroraMysql) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

func (m *AuroraMysql) GetDatabase() string {
	if m != nil {
		return m.Database
	}
	return ""
}

func (m *AuroraMysql) GetPortOverride() int32 {
	if m != nil {
		return m.PortOverride
	}
	return 0
}

func (m *AuroraMysql) GetPort() int32 {
	if m != nil {
		return m.Port
	}
	return 0
}

type Clustrix struct {
	// Unique identifier of the Resource.
	Id string `protobuf:"bytes,32768,opt,name=id,proto3" json:"id,omitempty"`
	// Unique human-readable name of the Resource.
	Name string `protobuf:"bytes,32769,opt,name=name,proto3" json:"name,omitempty"`
	// True if the datasource is reachable and the credentials are valid.
	Healthy bool `protobuf:"varint,32770,opt,name=healthy,proto3" json:"healthy,omitempty"`
	// Tags is a map of key, value pairs.
	Tags                 []*Pair  `protobuf:"bytes,32771,rep,name=tags,proto3" json:"tags,omitempty"`
	Hostname             string   `protobuf:"bytes,1,opt,name=hostname,proto3" json:"hostname,omitempty"`
	Username             string   `protobuf:"bytes,2,opt,name=username,proto3" json:"username,omitempty"`
	Password             string   `protobuf:"bytes,3,opt,name=password,proto3" json:"password,omitempty"`
	Database             string   `protobuf:"bytes,4,opt,name=database,proto3" json:"database,omitempty"`
	PortOverride         int32    `protobuf:"varint,5,opt,name=port_override,json=portOverride,proto3" json:"port_override,omitempty"`
	Port                 int32    `protobuf:"varint,6,opt,name=port,proto3" json:"port,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Clustrix) Reset()         { *m = Clustrix{} }
func (m *Clustrix) String() string { return proto.CompactTextString(m) }
func (*Clustrix) ProtoMessage()    {}
func (*Clustrix) Descriptor() ([]byte, []int) {
	return fileDescriptor_81dfd49b5b303fb4, []int{26}
}

func (m *Clustrix) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Clustrix.Unmarshal(m, b)
}
func (m *Clustrix) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Clustrix.Marshal(b, m, deterministic)
}
func (m *Clustrix) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Clustrix.Merge(m, src)
}
func (m *Clustrix) XXX_Size() int {
	return xxx_messageInfo_Clustrix.Size(m)
}
func (m *Clustrix) XXX_DiscardUnknown() {
	xxx_messageInfo_Clustrix.DiscardUnknown(m)
}

var xxx_messageInfo_Clustrix proto.InternalMessageInfo

func (m *Clustrix) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Clustrix) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Clustrix) GetHealthy() bool {
	if m != nil {
		return m.Healthy
	}
	return false
}

func (m *Clustrix) GetTags() []*Pair {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *Clustrix) GetHostname() string {
	if m != nil {
		return m.Hostname
	}
	return ""
}

func (m *Clustrix) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *Clustrix) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

func (m *Clustrix) GetDatabase() string {
	if m != nil {
		return m.Database
	}
	return ""
}

func (m *Clustrix) GetPortOverride() int32 {
	if m != nil {
		return m.PortOverride
	}
	return 0
}

func (m *Clustrix) GetPort() int32 {
	if m != nil {
		return m.Port
	}
	return 0
}

type Maria struct {
	// Unique identifier of the Resource.
	Id string `protobuf:"bytes,32768,opt,name=id,proto3" json:"id,omitempty"`
	// Unique human-readable name of the Resource.
	Name string `protobuf:"bytes,32769,opt,name=name,proto3" json:"name,omitempty"`
	// True if the datasource is reachable and the credentials are valid.
	Healthy bool `protobuf:"varint,32770,opt,name=healthy,proto3" json:"healthy,omitempty"`
	// Tags is a map of key, value pairs.
	Tags                 []*Pair  `protobuf:"bytes,32771,rep,name=tags,proto3" json:"tags,omitempty"`
	Hostname             string   `protobuf:"bytes,1,opt,name=hostname,proto3" json:"hostname,omitempty"`
	Username             string   `protobuf:"bytes,2,opt,name=username,proto3" json:"username,omitempty"`
	Password             string   `protobuf:"bytes,3,opt,name=password,proto3" json:"password,omitempty"`
	Database             string   `protobuf:"bytes,4,opt,name=database,proto3" json:"database,omitempty"`
	PortOverride         int32    `protobuf:"varint,5,opt,name=port_override,json=portOverride,proto3" json:"port_override,omitempty"`
	Port                 int32    `protobuf:"varint,6,opt,name=port,proto3" json:"port,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Maria) Reset()         { *m = Maria{} }
func (m *Maria) String() string { return proto.CompactTextString(m) }
func (*Maria) ProtoMessage()    {}
func (*Maria) Descriptor() ([]byte, []int) {
	return fileDescriptor_81dfd49b5b303fb4, []int{27}
}

func (m *Maria) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Maria.Unmarshal(m, b)
}
func (m *Maria) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Maria.Marshal(b, m, deterministic)
}
func (m *Maria) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Maria.Merge(m, src)
}
func (m *Maria) XXX_Size() int {
	return xxx_messageInfo_Maria.Size(m)
}
func (m *Maria) XXX_DiscardUnknown() {
	xxx_messageInfo_Maria.DiscardUnknown(m)
}

var xxx_messageInfo_Maria proto.InternalMessageInfo

func (m *Maria) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Maria) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Maria) GetHealthy() bool {
	if m != nil {
		return m.Healthy
	}
	return false
}

func (m *Maria) GetTags() []*Pair {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *Maria) GetHostname() string {
	if m != nil {
		return m.Hostname
	}
	return ""
}

func (m *Maria) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *Maria) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

func (m *Maria) GetDatabase() string {
	if m != nil {
		return m.Database
	}
	return ""
}

func (m *Maria) GetPortOverride() int32 {
	if m != nil {
		return m.PortOverride
	}
	return 0
}

func (m *Maria) GetPort() int32 {
	if m != nil {
		return m.Port
	}
	return 0
}

type Memsql struct {
	// Unique identifier of the Resource.
	Id string `protobuf:"bytes,32768,opt,name=id,proto3" json:"id,omitempty"`
	// Unique human-readable name of the Resource.
	Name string `protobuf:"bytes,32769,opt,name=name,proto3" json:"name,omitempty"`
	// True if the datasource is reachable and the credentials are valid.
	Healthy bool `protobuf:"varint,32770,opt,name=healthy,proto3" json:"healthy,omitempty"`
	// Tags is a map of key, value pairs.
	Tags                 []*Pair  `protobuf:"bytes,32771,rep,name=tags,proto3" json:"tags,omitempty"`
	Hostname             string   `protobuf:"bytes,1,opt,name=hostname,proto3" json:"hostname,omitempty"`
	Username             string   `protobuf:"bytes,2,opt,name=username,proto3" json:"username,omitempty"`
	Password             string   `protobuf:"bytes,3,opt,name=password,proto3" json:"password,omitempty"`
	Database             string   `protobuf:"bytes,4,opt,name=database,proto3" json:"database,omitempty"`
	PortOverride         int32    `protobuf:"varint,5,opt,name=port_override,json=portOverride,proto3" json:"port_override,omitempty"`
	Port                 int32    `protobuf:"varint,6,opt,name=port,proto3" json:"port,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Memsql) Reset()         { *m = Memsql{} }
func (m *Memsql) String() string { return proto.CompactTextString(m) }
func (*Memsql) ProtoMessage()    {}
func (*Memsql) Descriptor() ([]byte, []int) {
	return fileDescriptor_81dfd49b5b303fb4, []int{28}
}

func (m *Memsql) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Memsql.Unmarshal(m, b)
}
func (m *Memsql) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Memsql.Marshal(b, m, deterministic)
}
func (m *Memsql) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Memsql.Merge(m, src)
}
func (m *Memsql) XXX_Size() int {
	return xxx_messageInfo_Memsql.Size(m)
}
func (m *Memsql) XXX_DiscardUnknown() {
	xxx_messageInfo_Memsql.DiscardUnknown(m)
}

var xxx_messageInfo_Memsql proto.InternalMessageInfo

func (m *Memsql) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Memsql) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Memsql) GetHealthy() bool {
	if m != nil {
		return m.Healthy
	}
	return false
}

func (m *Memsql) GetTags() []*Pair {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *Memsql) GetHostname() string {
	if m != nil {
		return m.Hostname
	}
	return ""
}

func (m *Memsql) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *Memsql) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

func (m *Memsql) GetDatabase() string {
	if m != nil {
		return m.Database
	}
	return ""
}

func (m *Memsql) GetPortOverride() int32 {
	if m != nil {
		return m.PortOverride
	}
	return 0
}

func (m *Memsql) GetPort() int32 {
	if m != nil {
		return m.Port
	}
	return 0
}

type Oracle struct {
	// Unique identifier of the Resource.
	Id string `protobuf:"bytes,32768,opt,name=id,proto3" json:"id,omitempty"`
	// Unique human-readable name of the Resource.
	Name string `protobuf:"bytes,32769,opt,name=name,proto3" json:"name,omitempty"`
	// True if the datasource is reachable and the credentials are valid.
	Healthy bool `protobuf:"varint,32770,opt,name=healthy,proto3" json:"healthy,omitempty"`
	// Tags is a map of key, value pairs.
	Tags                 []*Pair  `protobuf:"bytes,32771,rep,name=tags,proto3" json:"tags,omitempty"`
	Hostname             string   `protobuf:"bytes,1,opt,name=hostname,proto3" json:"hostname,omitempty"`
	Username             string   `protobuf:"bytes,2,opt,name=username,proto3" json:"username,omitempty"`
	Password             string   `protobuf:"bytes,3,opt,name=password,proto3" json:"password,omitempty"`
	Database             string   `protobuf:"bytes,4,opt,name=database,proto3" json:"database,omitempty"`
	Port                 int32    `protobuf:"varint,5,opt,name=port,proto3" json:"port,omitempty"`
	PortOverride         int32    `protobuf:"varint,6,opt,name=port_override,json=portOverride,proto3" json:"port_override,omitempty"`
	TlsRequired          bool     `protobuf:"varint,7,opt,name=tls_required,json=tlsRequired,proto3" json:"tls_required,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Oracle) Reset()         { *m = Oracle{} }
func (m *Oracle) String() string { return proto.CompactTextString(m) }
func (*Oracle) ProtoMessage()    {}
func (*Oracle) Descriptor() ([]byte, []int) {
	return fileDescriptor_81dfd49b5b303fb4, []int{29}
}

func (m *Oracle) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Oracle.Unmarshal(m, b)
}
func (m *Oracle) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Oracle.Marshal(b, m, deterministic)
}
func (m *Oracle) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Oracle.Merge(m, src)
}
func (m *Oracle) XXX_Size() int {
	return xxx_messageInfo_Oracle.Size(m)
}
func (m *Oracle) XXX_DiscardUnknown() {
	xxx_messageInfo_Oracle.DiscardUnknown(m)
}

var xxx_messageInfo_Oracle proto.InternalMessageInfo

func (m *Oracle) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Oracle) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Oracle) GetHealthy() bool {
	if m != nil {
		return m.Healthy
	}
	return false
}

func (m *Oracle) GetTags() []*Pair {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *Oracle) GetHostname() string {
	if m != nil {
		return m.Hostname
	}
	return ""
}

func (m *Oracle) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *Oracle) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

func (m *Oracle) GetDatabase() string {
	if m != nil {
		return m.Database
	}
	return ""
}

func (m *Oracle) GetPort() int32 {
	if m != nil {
		return m.Port
	}
	return 0
}

func (m *Oracle) GetPortOverride() int32 {
	if m != nil {
		return m.PortOverride
	}
	return 0
}

func (m *Oracle) GetTlsRequired() bool {
	if m != nil {
		return m.TlsRequired
	}
	return false
}

type Postgres struct {
	// Unique identifier of the Resource.
	Id string `protobuf:"bytes,32768,opt,name=id,proto3" json:"id,omitempty"`
	// Unique human-readable name of the Resource.
	Name string `protobuf:"bytes,32769,opt,name=name,proto3" json:"name,omitempty"`
	// True if the datasource is reachable and the credentials are valid.
	Healthy bool `protobuf:"varint,32770,opt,name=healthy,proto3" json:"healthy,omitempty"`
	// Tags is a map of key, value pairs.
	Tags                 []*Pair  `protobuf:"bytes,32771,rep,name=tags,proto3" json:"tags,omitempty"`
	Hostname             string   `protobuf:"bytes,1,opt,name=hostname,proto3" json:"hostname,omitempty"`
	Username             string   `protobuf:"bytes,2,opt,name=username,proto3" json:"username,omitempty"`
	Password             string   `protobuf:"bytes,3,opt,name=password,proto3" json:"password,omitempty"`
	Database             string   `protobuf:"bytes,4,opt,name=database,proto3" json:"database,omitempty"`
	PortOverride         int32    `protobuf:"varint,5,opt,name=port_override,json=portOverride,proto3" json:"port_override,omitempty"`
	Port                 int32    `protobuf:"varint,6,opt,name=port,proto3" json:"port,omitempty"`
	OverrideDatabase     bool     `protobuf:"varint,7,opt,name=override_database,json=overrideDatabase,proto3" json:"override_database,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Postgres) Reset()         { *m = Postgres{} }
func (m *Postgres) String() string { return proto.CompactTextString(m) }
func (*Postgres) ProtoMessage()    {}
func (*Postgres) Descriptor() ([]byte, []int) {
	return fileDescriptor_81dfd49b5b303fb4, []int{30}
}

func (m *Postgres) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Postgres.Unmarshal(m, b)
}
func (m *Postgres) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Postgres.Marshal(b, m, deterministic)
}
func (m *Postgres) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Postgres.Merge(m, src)
}
func (m *Postgres) XXX_Size() int {
	return xxx_messageInfo_Postgres.Size(m)
}
func (m *Postgres) XXX_DiscardUnknown() {
	xxx_messageInfo_Postgres.DiscardUnknown(m)
}

var xxx_messageInfo_Postgres proto.InternalMessageInfo

func (m *Postgres) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Postgres) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Postgres) GetHealthy() bool {
	if m != nil {
		return m.Healthy
	}
	return false
}

func (m *Postgres) GetTags() []*Pair {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *Postgres) GetHostname() string {
	if m != nil {
		return m.Hostname
	}
	return ""
}

func (m *Postgres) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *Postgres) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

func (m *Postgres) GetDatabase() string {
	if m != nil {
		return m.Database
	}
	return ""
}

func (m *Postgres) GetPortOverride() int32 {
	if m != nil {
		return m.PortOverride
	}
	return 0
}

func (m *Postgres) GetPort() int32 {
	if m != nil {
		return m.Port
	}
	return 0
}

func (m *Postgres) GetOverrideDatabase() bool {
	if m != nil {
		return m.OverrideDatabase
	}
	return false
}

type AuroraPostgres struct {
	// Unique identifier of the Resource.
	Id string `protobuf:"bytes,32768,opt,name=id,proto3" json:"id,omitempty"`
	// Unique human-readable name of the Resource.
	Name string `protobuf:"bytes,32769,opt,name=name,proto3" json:"name,omitempty"`
	// True if the datasource is reachable and the credentials are valid.
	Healthy bool `protobuf:"varint,32770,opt,name=healthy,proto3" json:"healthy,omitempty"`
	// Tags is a map of key, value pairs.
	Tags                 []*Pair  `protobuf:"bytes,32771,rep,name=tags,proto3" json:"tags,omitempty"`
	Hostname             string   `protobuf:"bytes,1,opt,name=hostname,proto3" json:"hostname,omitempty"`
	Username             string   `protobuf:"bytes,2,opt,name=username,proto3" json:"username,omitempty"`
	Password             string   `protobuf:"bytes,3,opt,name=password,proto3" json:"password,omitempty"`
	Database             string   `protobuf:"bytes,4,opt,name=database,proto3" json:"database,omitempty"`
	PortOverride         int32    `protobuf:"varint,5,opt,name=port_override,json=portOverride,proto3" json:"port_override,omitempty"`
	Port                 int32    `protobuf:"varint,6,opt,name=port,proto3" json:"port,omitempty"`
	OverrideDatabase     bool     `protobuf:"varint,7,opt,name=override_database,json=overrideDatabase,proto3" json:"override_database,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AuroraPostgres) Reset()         { *m = AuroraPostgres{} }
func (m *AuroraPostgres) String() string { return proto.CompactTextString(m) }
func (*AuroraPostgres) ProtoMessage()    {}
func (*AuroraPostgres) Descriptor() ([]byte, []int) {
	return fileDescriptor_81dfd49b5b303fb4, []int{31}
}

func (m *AuroraPostgres) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AuroraPostgres.Unmarshal(m, b)
}
func (m *AuroraPostgres) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AuroraPostgres.Marshal(b, m, deterministic)
}
func (m *AuroraPostgres) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AuroraPostgres.Merge(m, src)
}
func (m *AuroraPostgres) XXX_Size() int {
	return xxx_messageInfo_AuroraPostgres.Size(m)
}
func (m *AuroraPostgres) XXX_DiscardUnknown() {
	xxx_messageInfo_AuroraPostgres.DiscardUnknown(m)
}

var xxx_messageInfo_AuroraPostgres proto.InternalMessageInfo

func (m *AuroraPostgres) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *AuroraPostgres) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *AuroraPostgres) GetHealthy() bool {
	if m != nil {
		return m.Healthy
	}
	return false
}

func (m *AuroraPostgres) GetTags() []*Pair {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *AuroraPostgres) GetHostname() string {
	if m != nil {
		return m.Hostname
	}
	return ""
}

func (m *AuroraPostgres) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *AuroraPostgres) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

func (m *AuroraPostgres) GetDatabase() string {
	if m != nil {
		return m.Database
	}
	return ""
}

func (m *AuroraPostgres) GetPortOverride() int32 {
	if m != nil {
		return m.PortOverride
	}
	return 0
}

func (m *AuroraPostgres) GetPort() int32 {
	if m != nil {
		return m.Port
	}
	return 0
}

func (m *AuroraPostgres) GetOverrideDatabase() bool {
	if m != nil {
		return m.OverrideDatabase
	}
	return false
}

type Greenplum struct {
	// Unique identifier of the Resource.
	Id string `protobuf:"bytes,32768,opt,name=id,proto3" json:"id,omitempty"`
	// Unique human-readable name of the Resource.
	Name string `protobuf:"bytes,32769,opt,name=name,proto3" json:"name,omitempty"`
	// True if the datasource is reachable and the credentials are valid.
	Healthy bool `protobuf:"varint,32770,opt,name=healthy,proto3" json:"healthy,omitempty"`
	// Tags is a map of key, value pairs.
	Tags                 []*Pair  `protobuf:"bytes,32771,rep,name=tags,proto3" json:"tags,omitempty"`
	Hostname             string   `protobuf:"bytes,1,opt,name=hostname,proto3" json:"hostname,omitempty"`
	Username             string   `protobuf:"bytes,2,opt,name=username,proto3" json:"username,omitempty"`
	Password             string   `protobuf:"bytes,3,opt,name=password,proto3" json:"password,omitempty"`
	Database             string   `protobuf:"bytes,4,opt,name=database,proto3" json:"database,omitempty"`
	PortOverride         int32    `protobuf:"varint,5,opt,name=port_override,json=portOverride,proto3" json:"port_override,omitempty"`
	Port                 int32    `protobuf:"varint,6,opt,name=port,proto3" json:"port,omitempty"`
	OverrideDatabase     bool     `protobuf:"varint,7,opt,name=override_database,json=overrideDatabase,proto3" json:"override_database,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Greenplum) Reset()         { *m = Greenplum{} }
func (m *Greenplum) String() string { return proto.CompactTextString(m) }
func (*Greenplum) ProtoMessage()    {}
func (*Greenplum) Descriptor() ([]byte, []int) {
	return fileDescriptor_81dfd49b5b303fb4, []int{32}
}

func (m *Greenplum) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Greenplum.Unmarshal(m, b)
}
func (m *Greenplum) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Greenplum.Marshal(b, m, deterministic)
}
func (m *Greenplum) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Greenplum.Merge(m, src)
}
func (m *Greenplum) XXX_Size() int {
	return xxx_messageInfo_Greenplum.Size(m)
}
func (m *Greenplum) XXX_DiscardUnknown() {
	xxx_messageInfo_Greenplum.DiscardUnknown(m)
}

var xxx_messageInfo_Greenplum proto.InternalMessageInfo

func (m *Greenplum) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Greenplum) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Greenplum) GetHealthy() bool {
	if m != nil {
		return m.Healthy
	}
	return false
}

func (m *Greenplum) GetTags() []*Pair {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *Greenplum) GetHostname() string {
	if m != nil {
		return m.Hostname
	}
	return ""
}

func (m *Greenplum) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *Greenplum) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

func (m *Greenplum) GetDatabase() string {
	if m != nil {
		return m.Database
	}
	return ""
}

func (m *Greenplum) GetPortOverride() int32 {
	if m != nil {
		return m.PortOverride
	}
	return 0
}

func (m *Greenplum) GetPort() int32 {
	if m != nil {
		return m.Port
	}
	return 0
}

func (m *Greenplum) GetOverrideDatabase() bool {
	if m != nil {
		return m.OverrideDatabase
	}
	return false
}

type Cockroach struct {
	// Unique identifier of the Resource.
	Id string `protobuf:"bytes,32768,opt,name=id,proto3" json:"id,omitempty"`
	// Unique human-readable name of the Resource.
	Name string `protobuf:"bytes,32769,opt,name=name,proto3" json:"name,omitempty"`
	// True if the datasource is reachable and the credentials are valid.
	Healthy bool `protobuf:"varint,32770,opt,name=healthy,proto3" json:"healthy,omitempty"`
	// Tags is a map of key, value pairs.
	Tags                 []*Pair  `protobuf:"bytes,32771,rep,name=tags,proto3" json:"tags,omitempty"`
	Hostname             string   `protobuf:"bytes,1,opt,name=hostname,proto3" json:"hostname,omitempty"`
	Username             string   `protobuf:"bytes,2,opt,name=username,proto3" json:"username,omitempty"`
	Password             string   `protobuf:"bytes,3,opt,name=password,proto3" json:"password,omitempty"`
	Database             string   `protobuf:"bytes,4,opt,name=database,proto3" json:"database,omitempty"`
	PortOverride         int32    `protobuf:"varint,5,opt,name=port_override,json=portOverride,proto3" json:"port_override,omitempty"`
	Port                 int32    `protobuf:"varint,6,opt,name=port,proto3" json:"port,omitempty"`
	OverrideDatabase     bool     `protobuf:"varint,7,opt,name=override_database,json=overrideDatabase,proto3" json:"override_database,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Cockroach) Reset()         { *m = Cockroach{} }
func (m *Cockroach) String() string { return proto.CompactTextString(m) }
func (*Cockroach) ProtoMessage()    {}
func (*Cockroach) Descriptor() ([]byte, []int) {
	return fileDescriptor_81dfd49b5b303fb4, []int{33}
}

func (m *Cockroach) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Cockroach.Unmarshal(m, b)
}
func (m *Cockroach) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Cockroach.Marshal(b, m, deterministic)
}
func (m *Cockroach) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Cockroach.Merge(m, src)
}
func (m *Cockroach) XXX_Size() int {
	return xxx_messageInfo_Cockroach.Size(m)
}
func (m *Cockroach) XXX_DiscardUnknown() {
	xxx_messageInfo_Cockroach.DiscardUnknown(m)
}

var xxx_messageInfo_Cockroach proto.InternalMessageInfo

func (m *Cockroach) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Cockroach) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Cockroach) GetHealthy() bool {
	if m != nil {
		return m.Healthy
	}
	return false
}

func (m *Cockroach) GetTags() []*Pair {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *Cockroach) GetHostname() string {
	if m != nil {
		return m.Hostname
	}
	return ""
}

func (m *Cockroach) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *Cockroach) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

func (m *Cockroach) GetDatabase() string {
	if m != nil {
		return m.Database
	}
	return ""
}

func (m *Cockroach) GetPortOverride() int32 {
	if m != nil {
		return m.PortOverride
	}
	return 0
}

func (m *Cockroach) GetPort() int32 {
	if m != nil {
		return m.Port
	}
	return 0
}

func (m *Cockroach) GetOverrideDatabase() bool {
	if m != nil {
		return m.OverrideDatabase
	}
	return false
}

type Redshift struct {
	// Unique identifier of the Resource.
	Id string `protobuf:"bytes,32768,opt,name=id,proto3" json:"id,omitempty"`
	// Unique human-readable name of the Resource.
	Name string `protobuf:"bytes,32769,opt,name=name,proto3" json:"name,omitempty"`
	// True if the datasource is reachable and the credentials are valid.
	Healthy bool `protobuf:"varint,32770,opt,name=healthy,proto3" json:"healthy,omitempty"`
	// Tags is a map of key, value pairs.
	Tags                 []*Pair  `protobuf:"bytes,32771,rep,name=tags,proto3" json:"tags,omitempty"`
	Hostname             string   `protobuf:"bytes,1,opt,name=hostname,proto3" json:"hostname,omitempty"`
	Username             string   `protobuf:"bytes,2,opt,name=username,proto3" json:"username,omitempty"`
	Password             string   `protobuf:"bytes,3,opt,name=password,proto3" json:"password,omitempty"`
	Database             string   `protobuf:"bytes,4,opt,name=database,proto3" json:"database,omitempty"`
	PortOverride         int32    `protobuf:"varint,5,opt,name=port_override,json=portOverride,proto3" json:"port_override,omitempty"`
	Port                 int32    `protobuf:"varint,6,opt,name=port,proto3" json:"port,omitempty"`
	OverrideDatabase     bool     `protobuf:"varint,7,opt,name=override_database,json=overrideDatabase,proto3" json:"override_database,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Redshift) Reset()         { *m = Redshift{} }
func (m *Redshift) String() string { return proto.CompactTextString(m) }
func (*Redshift) ProtoMessage()    {}
func (*Redshift) Descriptor() ([]byte, []int) {
	return fileDescriptor_81dfd49b5b303fb4, []int{34}
}

func (m *Redshift) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Redshift.Unmarshal(m, b)
}
func (m *Redshift) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Redshift.Marshal(b, m, deterministic)
}
func (m *Redshift) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Redshift.Merge(m, src)
}
func (m *Redshift) XXX_Size() int {
	return xxx_messageInfo_Redshift.Size(m)
}
func (m *Redshift) XXX_DiscardUnknown() {
	xxx_messageInfo_Redshift.DiscardUnknown(m)
}

var xxx_messageInfo_Redshift proto.InternalMessageInfo

func (m *Redshift) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Redshift) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Redshift) GetHealthy() bool {
	if m != nil {
		return m.Healthy
	}
	return false
}

func (m *Redshift) GetTags() []*Pair {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *Redshift) GetHostname() string {
	if m != nil {
		return m.Hostname
	}
	return ""
}

func (m *Redshift) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *Redshift) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

func (m *Redshift) GetDatabase() string {
	if m != nil {
		return m.Database
	}
	return ""
}

func (m *Redshift) GetPortOverride() int32 {
	if m != nil {
		return m.PortOverride
	}
	return 0
}

func (m *Redshift) GetPort() int32 {
	if m != nil {
		return m.Port
	}
	return 0
}

func (m *Redshift) GetOverrideDatabase() bool {
	if m != nil {
		return m.OverrideDatabase
	}
	return false
}

type Presto struct {
	// Unique identifier of the Resource.
	Id string `protobuf:"bytes,32768,opt,name=id,proto3" json:"id,omitempty"`
	// Unique human-readable name of the Resource.
	Name string `protobuf:"bytes,32769,opt,name=name,proto3" json:"name,omitempty"`
	// True if the datasource is reachable and the credentials are valid.
	Healthy bool `protobuf:"varint,32770,opt,name=healthy,proto3" json:"healthy,omitempty"`
	// Tags is a map of key, value pairs.
	Tags                 []*Pair  `protobuf:"bytes,32771,rep,name=tags,proto3" json:"tags,omitempty"`
	Hostname             string   `protobuf:"bytes,1,opt,name=hostname,proto3" json:"hostname,omitempty"`
	Password             string   `protobuf:"bytes,2,opt,name=password,proto3" json:"password,omitempty"`
	Database             string   `protobuf:"bytes,3,opt,name=database,proto3" json:"database,omitempty"`
	PortOverride         int32    `protobuf:"varint,4,opt,name=port_override,json=portOverride,proto3" json:"port_override,omitempty"`
	Port                 int32    `protobuf:"varint,5,opt,name=port,proto3" json:"port,omitempty"`
	Username             string   `protobuf:"bytes,6,opt,name=username,proto3" json:"username,omitempty"`
	TlsRequired          bool     `protobuf:"varint,7,opt,name=tls_required,json=tlsRequired,proto3" json:"tls_required,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Presto) Reset()         { *m = Presto{} }
func (m *Presto) String() string { return proto.CompactTextString(m) }
func (*Presto) ProtoMessage()    {}
func (*Presto) Descriptor() ([]byte, []int) {
	return fileDescriptor_81dfd49b5b303fb4, []int{35}
}

func (m *Presto) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Presto.Unmarshal(m, b)
}
func (m *Presto) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Presto.Marshal(b, m, deterministic)
}
func (m *Presto) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Presto.Merge(m, src)
}
func (m *Presto) XXX_Size() int {
	return xxx_messageInfo_Presto.Size(m)
}
func (m *Presto) XXX_DiscardUnknown() {
	xxx_messageInfo_Presto.DiscardUnknown(m)
}

var xxx_messageInfo_Presto proto.InternalMessageInfo

func (m *Presto) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Presto) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Presto) GetHealthy() bool {
	if m != nil {
		return m.Healthy
	}
	return false
}

func (m *Presto) GetTags() []*Pair {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *Presto) GetHostname() string {
	if m != nil {
		return m.Hostname
	}
	return ""
}

func (m *Presto) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

func (m *Presto) GetDatabase() string {
	if m != nil {
		return m.Database
	}
	return ""
}

func (m *Presto) GetPortOverride() int32 {
	if m != nil {
		return m.PortOverride
	}
	return 0
}

func (m *Presto) GetPort() int32 {
	if m != nil {
		return m.Port
	}
	return 0
}

func (m *Presto) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *Presto) GetTlsRequired() bool {
	if m != nil {
		return m.TlsRequired
	}
	return false
}

type RDP struct {
	// Unique identifier of the Resource.
	Id string `protobuf:"bytes,32768,opt,name=id,proto3" json:"id,omitempty"`
	// Unique human-readable name of the Resource.
	Name string `protobuf:"bytes,32769,opt,name=name,proto3" json:"name,omitempty"`
	// True if the datasource is reachable and the credentials are valid.
	Healthy bool `protobuf:"varint,32770,opt,name=healthy,proto3" json:"healthy,omitempty"`
	// Tags is a map of key, value pairs.
	Tags                 []*Pair  `protobuf:"bytes,32771,rep,name=tags,proto3" json:"tags,omitempty"`
	Hostname             string   `protobuf:"bytes,1,opt,name=hostname,proto3" json:"hostname,omitempty"`
	Username             string   `protobuf:"bytes,2,opt,name=username,proto3" json:"username,omitempty"`
	Password             string   `protobuf:"bytes,3,opt,name=password,proto3" json:"password,omitempty"`
	PortOverride         int32    `protobuf:"varint,4,opt,name=port_override,json=portOverride,proto3" json:"port_override,omitempty"`
	Port                 int32    `protobuf:"varint,5,opt,name=port,proto3" json:"port,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RDP) Reset()         { *m = RDP{} }
func (m *RDP) String() string { return proto.CompactTextString(m) }
func (*RDP) ProtoMessage()    {}
func (*RDP) Descriptor() ([]byte, []int) {
	return fileDescriptor_81dfd49b5b303fb4, []int{36}
}

func (m *RDP) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RDP.Unmarshal(m, b)
}
func (m *RDP) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RDP.Marshal(b, m, deterministic)
}
func (m *RDP) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RDP.Merge(m, src)
}
func (m *RDP) XXX_Size() int {
	return xxx_messageInfo_RDP.Size(m)
}
func (m *RDP) XXX_DiscardUnknown() {
	xxx_messageInfo_RDP.DiscardUnknown(m)
}

var xxx_messageInfo_RDP proto.InternalMessageInfo

func (m *RDP) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *RDP) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *RDP) GetHealthy() bool {
	if m != nil {
		return m.Healthy
	}
	return false
}

func (m *RDP) GetTags() []*Pair {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *RDP) GetHostname() string {
	if m != nil {
		return m.Hostname
	}
	return ""
}

func (m *RDP) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *RDP) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

func (m *RDP) GetPortOverride() int32 {
	if m != nil {
		return m.PortOverride
	}
	return 0
}

func (m *RDP) GetPort() int32 {
	if m != nil {
		return m.Port
	}
	return 0
}

type Redis struct {
	// Unique identifier of the Resource.
	Id string `protobuf:"bytes,32768,opt,name=id,proto3" json:"id,omitempty"`
	// Unique human-readable name of the Resource.
	Name string `protobuf:"bytes,32769,opt,name=name,proto3" json:"name,omitempty"`
	// True if the datasource is reachable and the credentials are valid.
	Healthy bool `protobuf:"varint,32770,opt,name=healthy,proto3" json:"healthy,omitempty"`
	// Tags is a map of key, value pairs.
	Tags                 []*Pair  `protobuf:"bytes,32771,rep,name=tags,proto3" json:"tags,omitempty"`
	Hostname             string   `protobuf:"bytes,1,opt,name=hostname,proto3" json:"hostname,omitempty"`
	PortOverride         int32    `protobuf:"varint,2,opt,name=port_override,json=portOverride,proto3" json:"port_override,omitempty"`
	Password             string   `protobuf:"bytes,3,opt,name=password,proto3" json:"password,omitempty"`
	Port                 int32    `protobuf:"varint,4,opt,name=port,proto3" json:"port,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Redis) Reset()         { *m = Redis{} }
func (m *Redis) String() string { return proto.CompactTextString(m) }
func (*Redis) ProtoMessage()    {}
func (*Redis) Descriptor() ([]byte, []int) {
	return fileDescriptor_81dfd49b5b303fb4, []int{37}
}

func (m *Redis) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Redis.Unmarshal(m, b)
}
func (m *Redis) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Redis.Marshal(b, m, deterministic)
}
func (m *Redis) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Redis.Merge(m, src)
}
func (m *Redis) XXX_Size() int {
	return xxx_messageInfo_Redis.Size(m)
}
func (m *Redis) XXX_DiscardUnknown() {
	xxx_messageInfo_Redis.DiscardUnknown(m)
}

var xxx_messageInfo_Redis proto.InternalMessageInfo

func (m *Redis) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Redis) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Redis) GetHealthy() bool {
	if m != nil {
		return m.Healthy
	}
	return false
}

func (m *Redis) GetTags() []*Pair {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *Redis) GetHostname() string {
	if m != nil {
		return m.Hostname
	}
	return ""
}

func (m *Redis) GetPortOverride() int32 {
	if m != nil {
		return m.PortOverride
	}
	return 0
}

func (m *Redis) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

func (m *Redis) GetPort() int32 {
	if m != nil {
		return m.Port
	}
	return 0
}

type ElasticacheRedis struct {
	// Unique identifier of the Resource.
	Id string `protobuf:"bytes,32768,opt,name=id,proto3" json:"id,omitempty"`
	// Unique human-readable name of the Resource.
	Name string `protobuf:"bytes,32769,opt,name=name,proto3" json:"name,omitempty"`
	// True if the datasource is reachable and the credentials are valid.
	Healthy bool `protobuf:"varint,32770,opt,name=healthy,proto3" json:"healthy,omitempty"`
	// Tags is a map of key, value pairs.
	Tags                 []*Pair  `protobuf:"bytes,32771,rep,name=tags,proto3" json:"tags,omitempty"`
	Hostname             string   `protobuf:"bytes,1,opt,name=hostname,proto3" json:"hostname,omitempty"`
	PortOverride         int32    `protobuf:"varint,2,opt,name=port_override,json=portOverride,proto3" json:"port_override,omitempty"`
	Password             string   `protobuf:"bytes,3,opt,name=password,proto3" json:"password,omitempty"`
	Port                 int32    `protobuf:"varint,4,opt,name=port,proto3" json:"port,omitempty"`
	TlsRequired          bool     `protobuf:"varint,5,opt,name=tls_required,json=tlsRequired,proto3" json:"tls_required,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ElasticacheRedis) Reset()         { *m = ElasticacheRedis{} }
func (m *ElasticacheRedis) String() string { return proto.CompactTextString(m) }
func (*ElasticacheRedis) ProtoMessage()    {}
func (*ElasticacheRedis) Descriptor() ([]byte, []int) {
	return fileDescriptor_81dfd49b5b303fb4, []int{38}
}

func (m *ElasticacheRedis) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ElasticacheRedis.Unmarshal(m, b)
}
func (m *ElasticacheRedis) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ElasticacheRedis.Marshal(b, m, deterministic)
}
func (m *ElasticacheRedis) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ElasticacheRedis.Merge(m, src)
}
func (m *ElasticacheRedis) XXX_Size() int {
	return xxx_messageInfo_ElasticacheRedis.Size(m)
}
func (m *ElasticacheRedis) XXX_DiscardUnknown() {
	xxx_messageInfo_ElasticacheRedis.DiscardUnknown(m)
}

var xxx_messageInfo_ElasticacheRedis proto.InternalMessageInfo

func (m *ElasticacheRedis) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *ElasticacheRedis) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ElasticacheRedis) GetHealthy() bool {
	if m != nil {
		return m.Healthy
	}
	return false
}

func (m *ElasticacheRedis) GetTags() []*Pair {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *ElasticacheRedis) GetHostname() string {
	if m != nil {
		return m.Hostname
	}
	return ""
}

func (m *ElasticacheRedis) GetPortOverride() int32 {
	if m != nil {
		return m.PortOverride
	}
	return 0
}

func (m *ElasticacheRedis) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

func (m *ElasticacheRedis) GetPort() int32 {
	if m != nil {
		return m.Port
	}
	return 0
}

func (m *ElasticacheRedis) GetTlsRequired() bool {
	if m != nil {
		return m.TlsRequired
	}
	return false
}

type Snowflake struct {
	// Unique identifier of the Resource.
	Id string `protobuf:"bytes,32768,opt,name=id,proto3" json:"id,omitempty"`
	// Unique human-readable name of the Resource.
	Name string `protobuf:"bytes,32769,opt,name=name,proto3" json:"name,omitempty"`
	// True if the datasource is reachable and the credentials are valid.
	Healthy bool `protobuf:"varint,32770,opt,name=healthy,proto3" json:"healthy,omitempty"`
	// Tags is a map of key, value pairs.
	Tags                 []*Pair  `protobuf:"bytes,32771,rep,name=tags,proto3" json:"tags,omitempty"`
	Hostname             string   `protobuf:"bytes,1,opt,name=hostname,proto3" json:"hostname,omitempty"`
	Username             string   `protobuf:"bytes,2,opt,name=username,proto3" json:"username,omitempty"`
	Password             string   `protobuf:"bytes,3,opt,name=password,proto3" json:"password,omitempty"`
	Database             string   `protobuf:"bytes,4,opt,name=database,proto3" json:"database,omitempty"`
	Schema               string   `protobuf:"bytes,5,opt,name=schema,proto3" json:"schema,omitempty"`
	PortOverride         int32    `protobuf:"varint,6,opt,name=port_override,json=portOverride,proto3" json:"port_override,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Snowflake) Reset()         { *m = Snowflake{} }
func (m *Snowflake) String() string { return proto.CompactTextString(m) }
func (*Snowflake) ProtoMessage()    {}
func (*Snowflake) Descriptor() ([]byte, []int) {
	return fileDescriptor_81dfd49b5b303fb4, []int{39}
}

func (m *Snowflake) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Snowflake.Unmarshal(m, b)
}
func (m *Snowflake) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Snowflake.Marshal(b, m, deterministic)
}
func (m *Snowflake) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Snowflake.Merge(m, src)
}
func (m *Snowflake) XXX_Size() int {
	return xxx_messageInfo_Snowflake.Size(m)
}
func (m *Snowflake) XXX_DiscardUnknown() {
	xxx_messageInfo_Snowflake.DiscardUnknown(m)
}

var xxx_messageInfo_Snowflake proto.InternalMessageInfo

func (m *Snowflake) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Snowflake) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Snowflake) GetHealthy() bool {
	if m != nil {
		return m.Healthy
	}
	return false
}

func (m *Snowflake) GetTags() []*Pair {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *Snowflake) GetHostname() string {
	if m != nil {
		return m.Hostname
	}
	return ""
}

func (m *Snowflake) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *Snowflake) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

func (m *Snowflake) GetDatabase() string {
	if m != nil {
		return m.Database
	}
	return ""
}

func (m *Snowflake) GetSchema() string {
	if m != nil {
		return m.Schema
	}
	return ""
}

func (m *Snowflake) GetPortOverride() int32 {
	if m != nil {
		return m.PortOverride
	}
	return 0
}

type SQLServer struct {
	// Unique identifier of the Resource.
	Id string `protobuf:"bytes,32768,opt,name=id,proto3" json:"id,omitempty"`
	// Unique human-readable name of the Resource.
	Name string `protobuf:"bytes,32769,opt,name=name,proto3" json:"name,omitempty"`
	// True if the datasource is reachable and the credentials are valid.
	Healthy bool `protobuf:"varint,32770,opt,name=healthy,proto3" json:"healthy,omitempty"`
	// Tags is a map of key, value pairs.
	Tags                 []*Pair  `protobuf:"bytes,32771,rep,name=tags,proto3" json:"tags,omitempty"`
	Hostname             string   `protobuf:"bytes,1,opt,name=hostname,proto3" json:"hostname,omitempty"`
	Username             string   `protobuf:"bytes,2,opt,name=username,proto3" json:"username,omitempty"`
	Password             string   `protobuf:"bytes,3,opt,name=password,proto3" json:"password,omitempty"`
	Database             string   `protobuf:"bytes,4,opt,name=database,proto3" json:"database,omitempty"`
	PortOverride         int32    `protobuf:"varint,5,opt,name=port_override,json=portOverride,proto3" json:"port_override,omitempty"`
	Schema               string   `protobuf:"bytes,6,opt,name=schema,proto3" json:"schema,omitempty"`
	Port                 int32    `protobuf:"varint,7,opt,name=port,proto3" json:"port,omitempty"`
	OverrideDatabase     bool     `protobuf:"varint,8,opt,name=override_database,json=overrideDatabase,proto3" json:"override_database,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SQLServer) Reset()         { *m = SQLServer{} }
func (m *SQLServer) String() string { return proto.CompactTextString(m) }
func (*SQLServer) ProtoMessage()    {}
func (*SQLServer) Descriptor() ([]byte, []int) {
	return fileDescriptor_81dfd49b5b303fb4, []int{40}
}

func (m *SQLServer) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SQLServer.Unmarshal(m, b)
}
func (m *SQLServer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SQLServer.Marshal(b, m, deterministic)
}
func (m *SQLServer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SQLServer.Merge(m, src)
}
func (m *SQLServer) XXX_Size() int {
	return xxx_messageInfo_SQLServer.Size(m)
}
func (m *SQLServer) XXX_DiscardUnknown() {
	xxx_messageInfo_SQLServer.DiscardUnknown(m)
}

var xxx_messageInfo_SQLServer proto.InternalMessageInfo

func (m *SQLServer) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *SQLServer) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *SQLServer) GetHealthy() bool {
	if m != nil {
		return m.Healthy
	}
	return false
}

func (m *SQLServer) GetTags() []*Pair {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *SQLServer) GetHostname() string {
	if m != nil {
		return m.Hostname
	}
	return ""
}

func (m *SQLServer) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *SQLServer) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

func (m *SQLServer) GetDatabase() string {
	if m != nil {
		return m.Database
	}
	return ""
}

func (m *SQLServer) GetPortOverride() int32 {
	if m != nil {
		return m.PortOverride
	}
	return 0
}

func (m *SQLServer) GetSchema() string {
	if m != nil {
		return m.Schema
	}
	return ""
}

func (m *SQLServer) GetPort() int32 {
	if m != nil {
		return m.Port
	}
	return 0
}

func (m *SQLServer) GetOverrideDatabase() bool {
	if m != nil {
		return m.OverrideDatabase
	}
	return false
}

type SSH struct {
	// Unique identifier of the Resource.
	Id string `protobuf:"bytes,32768,opt,name=id,proto3" json:"id,omitempty"`
	// Unique human-readable name of the Resource.
	Name string `protobuf:"bytes,32769,opt,name=name,proto3" json:"name,omitempty"`
	// True if the datasource is reachable and the credentials are valid.
	Healthy bool `protobuf:"varint,32770,opt,name=healthy,proto3" json:"healthy,omitempty"`
	// Tags is a map of key, value pairs.
	Tags                 []*Pair  `protobuf:"bytes,32771,rep,name=tags,proto3" json:"tags,omitempty"`
	Hostname             string   `protobuf:"bytes,1,opt,name=hostname,proto3" json:"hostname,omitempty"`
	Username             string   `protobuf:"bytes,2,opt,name=username,proto3" json:"username,omitempty"`
	Port                 int32    `protobuf:"varint,3,opt,name=port,proto3" json:"port,omitempty"`
	PublicKey            string   `protobuf:"bytes,4,opt,name=public_key,json=publicKey,proto3" json:"public_key,omitempty"`
	PortForwarding       bool     `protobuf:"varint,5,opt,name=port_forwarding,json=portForwarding,proto3" json:"port_forwarding,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SSH) Reset()         { *m = SSH{} }
func (m *SSH) String() string { return proto.CompactTextString(m) }
func (*SSH) ProtoMessage()    {}
func (*SSH) Descriptor() ([]byte, []int) {
	return fileDescriptor_81dfd49b5b303fb4, []int{41}
}

func (m *SSH) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SSH.Unmarshal(m, b)
}
func (m *SSH) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SSH.Marshal(b, m, deterministic)
}
func (m *SSH) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SSH.Merge(m, src)
}
func (m *SSH) XXX_Size() int {
	return xxx_messageInfo_SSH.Size(m)
}
func (m *SSH) XXX_DiscardUnknown() {
	xxx_messageInfo_SSH.DiscardUnknown(m)
}

var xxx_messageInfo_SSH proto.InternalMessageInfo

func (m *SSH) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *SSH) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *SSH) GetHealthy() bool {
	if m != nil {
		return m.Healthy
	}
	return false
}

func (m *SSH) GetTags() []*Pair {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *SSH) GetHostname() string {
	if m != nil {
		return m.Hostname
	}
	return ""
}

func (m *SSH) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *SSH) GetPort() int32 {
	if m != nil {
		return m.Port
	}
	return 0
}

func (m *SSH) GetPublicKey() string {
	if m != nil {
		return m.PublicKey
	}
	return ""
}

func (m *SSH) GetPortForwarding() bool {
	if m != nil {
		return m.PortForwarding
	}
	return false
}

type Sybase struct {
	// Unique identifier of the Resource.
	Id string `protobuf:"bytes,32768,opt,name=id,proto3" json:"id,omitempty"`
	// Unique human-readable name of the Resource.
	Name string `protobuf:"bytes,32769,opt,name=name,proto3" json:"name,omitempty"`
	// True if the datasource is reachable and the credentials are valid.
	Healthy bool `protobuf:"varint,32770,opt,name=healthy,proto3" json:"healthy,omitempty"`
	// Tags is a map of key, value pairs.
	Tags                 []*Pair  `protobuf:"bytes,32771,rep,name=tags,proto3" json:"tags,omitempty"`
	Hostname             string   `protobuf:"bytes,1,opt,name=hostname,proto3" json:"hostname,omitempty"`
	Username             string   `protobuf:"bytes,2,opt,name=username,proto3" json:"username,omitempty"`
	PortOverride         int32    `protobuf:"varint,3,opt,name=port_override,json=portOverride,proto3" json:"port_override,omitempty"`
	Port                 int32    `protobuf:"varint,4,opt,name=port,proto3" json:"port,omitempty"`
	Password             string   `protobuf:"bytes,5,opt,name=password,proto3" json:"password,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Sybase) Reset()         { *m = Sybase{} }
func (m *Sybase) String() string { return proto.CompactTextString(m) }
func (*Sybase) ProtoMessage()    {}
func (*Sybase) Descriptor() ([]byte, []int) {
	return fileDescriptor_81dfd49b5b303fb4, []int{42}
}

func (m *Sybase) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Sybase.Unmarshal(m, b)
}
func (m *Sybase) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Sybase.Marshal(b, m, deterministic)
}
func (m *Sybase) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Sybase.Merge(m, src)
}
func (m *Sybase) XXX_Size() int {
	return xxx_messageInfo_Sybase.Size(m)
}
func (m *Sybase) XXX_DiscardUnknown() {
	xxx_messageInfo_Sybase.DiscardUnknown(m)
}

var xxx_messageInfo_Sybase proto.InternalMessageInfo

func (m *Sybase) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Sybase) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Sybase) GetHealthy() bool {
	if m != nil {
		return m.Healthy
	}
	return false
}

func (m *Sybase) GetTags() []*Pair {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *Sybase) GetHostname() string {
	if m != nil {
		return m.Hostname
	}
	return ""
}

func (m *Sybase) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *Sybase) GetPortOverride() int32 {
	if m != nil {
		return m.PortOverride
	}
	return 0
}

func (m *Sybase) GetPort() int32 {
	if m != nil {
		return m.Port
	}
	return 0
}

func (m *Sybase) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

type SybaseIQ struct {
	// Unique identifier of the Resource.
	Id string `protobuf:"bytes,32768,opt,name=id,proto3" json:"id,omitempty"`
	// Unique human-readable name of the Resource.
	Name string `protobuf:"bytes,32769,opt,name=name,proto3" json:"name,omitempty"`
	// True if the datasource is reachable and the credentials are valid.
	Healthy bool `protobuf:"varint,32770,opt,name=healthy,proto3" json:"healthy,omitempty"`
	// Tags is a map of key, value pairs.
	Tags                 []*Pair  `protobuf:"bytes,32771,rep,name=tags,proto3" json:"tags,omitempty"`
	Hostname             string   `protobuf:"bytes,1,opt,name=hostname,proto3" json:"hostname,omitempty"`
	Username             string   `protobuf:"bytes,2,opt,name=username,proto3" json:"username,omitempty"`
	PortOverride         int32    `protobuf:"varint,3,opt,name=port_override,json=portOverride,proto3" json:"port_override,omitempty"`
	Port                 int32    `protobuf:"varint,4,opt,name=port,proto3" json:"port,omitempty"`
	Password             string   `protobuf:"bytes,5,opt,name=password,proto3" json:"password,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SybaseIQ) Reset()         { *m = SybaseIQ{} }
func (m *SybaseIQ) String() string { return proto.CompactTextString(m) }
func (*SybaseIQ) ProtoMessage()    {}
func (*SybaseIQ) Descriptor() ([]byte, []int) {
	return fileDescriptor_81dfd49b5b303fb4, []int{43}
}

func (m *SybaseIQ) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SybaseIQ.Unmarshal(m, b)
}
func (m *SybaseIQ) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SybaseIQ.Marshal(b, m, deterministic)
}
func (m *SybaseIQ) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SybaseIQ.Merge(m, src)
}
func (m *SybaseIQ) XXX_Size() int {
	return xxx_messageInfo_SybaseIQ.Size(m)
}
func (m *SybaseIQ) XXX_DiscardUnknown() {
	xxx_messageInfo_SybaseIQ.DiscardUnknown(m)
}

var xxx_messageInfo_SybaseIQ proto.InternalMessageInfo

func (m *SybaseIQ) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *SybaseIQ) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *SybaseIQ) GetHealthy() bool {
	if m != nil {
		return m.Healthy
	}
	return false
}

func (m *SybaseIQ) GetTags() []*Pair {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *SybaseIQ) GetHostname() string {
	if m != nil {
		return m.Hostname
	}
	return ""
}

func (m *SybaseIQ) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *SybaseIQ) GetPortOverride() int32 {
	if m != nil {
		return m.PortOverride
	}
	return 0
}

func (m *SybaseIQ) GetPort() int32 {
	if m != nil {
		return m.Port
	}
	return 0
}

func (m *SybaseIQ) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

type Teradata struct {
	// Unique identifier of the Resource.
	Id string `protobuf:"bytes,32768,opt,name=id,proto3" json:"id,omitempty"`
	// Unique human-readable name of the Resource.
	Name string `protobuf:"bytes,32769,opt,name=name,proto3" json:"name,omitempty"`
	// True if the datasource is reachable and the credentials are valid.
	Healthy bool `protobuf:"varint,32770,opt,name=healthy,proto3" json:"healthy,omitempty"`
	// Tags is a map of key, value pairs.
	Tags                 []*Pair  `protobuf:"bytes,32771,rep,name=tags,proto3" json:"tags,omitempty"`
	Hostname             string   `protobuf:"bytes,1,opt,name=hostname,proto3" json:"hostname,omitempty"`
	Username             string   `protobuf:"bytes,2,opt,name=username,proto3" json:"username,omitempty"`
	Password             string   `protobuf:"bytes,3,opt,name=password,proto3" json:"password,omitempty"`
	PortOverride         int32    `protobuf:"varint,4,opt,name=port_override,json=portOverride,proto3" json:"port_override,omitempty"`
	Port                 int32    `protobuf:"varint,5,opt,name=port,proto3" json:"port,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Teradata) Reset()         { *m = Teradata{} }
func (m *Teradata) String() string { return proto.CompactTextString(m) }
func (*Teradata) ProtoMessage()    {}
func (*Teradata) Descriptor() ([]byte, []int) {
	return fileDescriptor_81dfd49b5b303fb4, []int{44}
}

func (m *Teradata) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Teradata.Unmarshal(m, b)
}
func (m *Teradata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Teradata.Marshal(b, m, deterministic)
}
func (m *Teradata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Teradata.Merge(m, src)
}
func (m *Teradata) XXX_Size() int {
	return xxx_messageInfo_Teradata.Size(m)
}
func (m *Teradata) XXX_DiscardUnknown() {
	xxx_messageInfo_Teradata.DiscardUnknown(m)
}

var xxx_messageInfo_Teradata proto.InternalMessageInfo

func (m *Teradata) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Teradata) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Teradata) GetHealthy() bool {
	if m != nil {
		return m.Healthy
	}
	return false
}

func (m *Teradata) GetTags() []*Pair {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *Teradata) GetHostname() string {
	if m != nil {
		return m.Hostname
	}
	return ""
}

func (m *Teradata) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *Teradata) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

func (m *Teradata) GetPortOverride() int32 {
	if m != nil {
		return m.PortOverride
	}
	return 0
}

func (m *Teradata) GetPort() int32 {
	if m != nil {
		return m.Port
	}
	return 0
}

type Pair struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Value                string   `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Pair) Reset()         { *m = Pair{} }
func (m *Pair) String() string { return proto.CompactTextString(m) }
func (*Pair) ProtoMessage()    {}
func (*Pair) Descriptor() ([]byte, []int) {
	return fileDescriptor_81dfd49b5b303fb4, []int{45}
}

func (m *Pair) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Pair.Unmarshal(m, b)
}
func (m *Pair) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Pair.Marshal(b, m, deterministic)
}
func (m *Pair) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Pair.Merge(m, src)
}
func (m *Pair) XXX_Size() int {
	return xxx_messageInfo_Pair.Size(m)
}
func (m *Pair) XXX_DiscardUnknown() {
	xxx_messageInfo_Pair.DiscardUnknown(m)
}

var xxx_messageInfo_Pair proto.InternalMessageInfo

func (m *Pair) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Pair) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

func init() {
	proto.RegisterType((*Resource)(nil), "v1.Resource")
	proto.RegisterType((*Athena)(nil), "v1.Athena")
	proto.RegisterType((*BigQuery)(nil), "v1.BigQuery")
	proto.RegisterType((*Cassandra)(nil), "v1.Cassandra")
	proto.RegisterType((*Druid)(nil), "v1.Druid")
	proto.RegisterType((*DynamoDB)(nil), "v1.DynamoDB")
	proto.RegisterType((*AmazonES)(nil), "v1.AmazonES")
	proto.RegisterType((*Elastic)(nil), "v1.Elastic")
	proto.RegisterType((*HTTPBasicAuth)(nil), "v1.HTTPBasicAuth")
	proto.RegisterType((*HTTPNoAuth)(nil), "v1.HTTPNoAuth")
	proto.RegisterType((*HTTPAuth)(nil), "v1.HTTPAuth")
	proto.RegisterType((*Kubernetes)(nil), "v1.Kubernetes")
	proto.RegisterType((*KubernetesBasicAuth)(nil), "v1.KubernetesBasicAuth")
	proto.RegisterType((*KubernetesServiceAccount)(nil), "v1.KubernetesServiceAccount")
	proto.RegisterType((*AmazonEKS)(nil), "v1.AmazonEKS")
	proto.RegisterType((*GoogleGKE)(nil), "v1.GoogleGKE")
	proto.RegisterType((*AKS)(nil), "v1.AKS")
	proto.RegisterType((*AKSBasicAuth)(nil), "v1.AKSBasicAuth")
	proto.RegisterType((*AKSServiceAccount)(nil), "v1.AKSServiceAccount")
	proto.RegisterType((*Memcached)(nil), "v1.Memcached")
	proto.RegisterType((*MongoLegacyHost)(nil), "v1.MongoLegacyHost")
	proto.RegisterType((*MongoLegacyReplicaset)(nil), "v1.MongoLegacyReplicaset")
	proto.RegisterType((*MongoHost)(nil), "v1.MongoHost")
	proto.RegisterType((*MongoReplicaSet)(nil), "v1.MongoReplicaSet")
	proto.RegisterType((*Mysql)(nil), "v1.Mysql")
	proto.RegisterType((*AuroraMysql)(nil), "v1.AuroraMysql")
	proto.RegisterType((*Clustrix)(nil), "v1.Clustrix")
	proto.RegisterType((*Maria)(nil), "v1.Maria")
	proto.RegisterType((*Memsql)(nil), "v1.Memsql")
	proto.RegisterType((*Oracle)(nil), "v1.Oracle")
	proto.RegisterType((*Postgres)(nil), "v1.Postgres")
	proto.RegisterType((*AuroraPostgres)(nil), "v1.AuroraPostgres")
	proto.RegisterType((*Greenplum)(nil), "v1.Greenplum")
	proto.RegisterType((*Cockroach)(nil), "v1.Cockroach")
	proto.RegisterType((*Redshift)(nil), "v1.Redshift")
	proto.RegisterType((*Presto)(nil), "v1.Presto")
	proto.RegisterType((*RDP)(nil), "v1.RDP")
	proto.RegisterType((*Redis)(nil), "v1.Redis")
	proto.RegisterType((*ElasticacheRedis)(nil), "v1.ElasticacheRedis")
	proto.RegisterType((*Snowflake)(nil), "v1.Snowflake")
	proto.RegisterType((*SQLServer)(nil), "v1.SQLServer")
	proto.RegisterType((*SSH)(nil), "v1.SSH")
	proto.RegisterType((*Sybase)(nil), "v1.Sybase")
	proto.RegisterType((*SybaseIQ)(nil), "v1.SybaseIQ")
	proto.RegisterType((*Teradata)(nil), "v1.Teradata")
	proto.RegisterType((*Pair)(nil), "v1.Pair")
}

func init() { proto.RegisterFile("drivers.proto", fileDescriptor_81dfd49b5b303fb4) }

var fileDescriptor_81dfd49b5b303fb4 = []byte{
	// 3078 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x5d, 0x5b, 0x6c, 0x24, 0x47,
	0xd5, 0xb6, 0x3d, 0xdd, 0x3d, 0x33, 0x67, 0x7c, 0x59, 0xf7, 0xee, 0x2a, 0x9d, 0xfd, 0x57, 0xbf,
	0xc2, 0x12, 0x50, 0x48, 0xb2, 0x5e, 0x8f, 0xbd, 0x9b, 0xec, 0x3a, 0x90, 0x64, 0x66, 0xbd, 0x9b,
	0x89, 0x36, 0xc9, 0x3a, 0x63, 0x0b, 0x21, 0x21, 0xd4, 0x2a, 0x77, 0x97, 0x67, 0x9a, 0xb9, 0xf4,
	0xb8, 0xab, 0xc7, 0x1b, 0xf3, 0x14, 0x20, 0x48, 0x3c, 0x22, 0x0b, 0x08, 0x12, 0x0f, 0x90, 0xb0,
	0x04, 0x94, 0x20, 0x14, 0x61, 0x24, 0x22, 0x94, 0xa0, 0x84, 0x07, 0xc4, 0x03, 0x97, 0xf0, 0x16,
	0x24, 0x90, 0xb8, 0x8a, 0x5c, 0x40, 0x42, 0x59, 0x40, 0x11, 0x4f, 0xa8, 0xaa, 0xfa, 0x3a, 0x1e,
	0x6f, 0xa6, 0x67, 0xc6, 0xca, 0xda, 0xa9, 0x17, 0x6b, 0xfa, 0xd4, 0xf9, 0x4e, 0x57, 0xd5, 0xf9,
	0x4e, 0xdd, 0xba, 0xaa, 0x0c, 0x13, 0xa6, 0x63, 0x6d, 0x60, 0x87, 0xcc, 0xb4, 0x1c, 0xdb, 0xb5,
	0xd5, 0xb1, 0x8d, 0xfc, 0xb1, 0x3b, 0xd9, 0x4f, 0xe3, 0x64, 0x05, 0x37, 0x4f, 0x92, 0x2b, 0xa8,
	0x52, 0xc1, 0xce, 0x29, 0xbb, 0xe5, 0x5a, 0x76, 0x93, 0x9c, 0x42, 0xcd, 0xa6, 0xed, 0x22, 0xf6,
	0x9b, 0x23, 0x8e, 0x4d, 0x78, 0x49, 0xfc, 0xf1, 0xc4, 0x55, 0x15, 0x32, 0x65, 0x4c, 0xec, 0xb6,
	0x63, 0x60, 0xf5, 0x56, 0x50, 0x90, 0x5b, 0xc5, 0x4d, 0xa4, 0x99, 0xb7, 0x8c, 0xde, 0x96, 0x9b,
	0x83, 0x99, 0x8d, 0xfc, 0x4c, 0x81, 0x49, 0x4a, 0x23, 0x65, 0x2f, 0x4d, 0xbd, 0x13, 0xb2, 0xab,
	0x56, 0x45, 0x5f, 0x6f, 0x63, 0x67, 0x53, 0xfb, 0xf9, 0x28, 0xd3, 0x1c, 0xa7, 0x9a, 0x45, 0xab,
	0xf2, 0x28, 0x15, 0x96, 0x46, 0xca, 0x99, 0x55, 0xef, 0xb7, 0x3a, 0x03, 0x59, 0x03, 0x11, 0x82,
	0x9a, 0xa6, 0x83, 0xb4, 0xef, 0x8d, 0x31, 0xed, 0x09, 0xaa, 0x7d, 0xde, 0x97, 0x96, 0x46, 0xca,
	0xa1, 0x8a, 0x7a, 0x02, 0x64, 0xd3, 0x69, 0x5b, 0xa6, 0xf6, 0xa5, 0x14, 0xd3, 0xcd, 0x52, 0xdd,
	0x45, 0x2a, 0x29, 0x8d, 0x94, 0x79, 0x12, 0xcd, 0x81, 0xb9, 0xd9, 0x44, 0x0d, 0x5b, 0x37, 0x57,
	0xb5, 0x7f, 0xa5, 0xc2, 0x1c, 0x2c, 0x32, 0xe9, 0x62, 0x91, 0xe6, 0x80, 0x6b, 0x2c, 0xae, 0x52,
	0x6d, 0xd4, 0x40, 0x9f, 0xb1, 0x9b, 0x3a, 0x26, 0xda, 0x6b, 0x52, 0xa8, 0x5d, 0x60, 0xd2, 0x0b,
	0xcb, 0x54, 0x9b, 0x6b, 0x5c, 0x20, 0xea, 0x6d, 0x90, 0xc6, 0x75, 0x44, 0x5c, 0xcb, 0xd0, 0x7e,
	0xcb, 0x75, 0x73, 0x54, 0xf7, 0x02, 0x97, 0x95, 0x46, 0xca, 0x7e, 0xb2, 0xfa, 0x51, 0x98, 0xaa,
	0xba, 0x6e, 0x4b, 0x5f, 0x45, 0xc4, 0x32, 0x74, 0xd4, 0x76, 0xab, 0xda, 0x8b, 0x32, 0x43, 0x4c,
	0x53, 0x44, 0x69, 0x65, 0x65, 0xa9, 0x48, 0x93, 0x0a, 0x6d, 0xb7, 0x5a, 0x1a, 0x29, 0x4f, 0x50,
	0xe5, 0x40, 0xa0, 0xce, 0xc3, 0x38, 0x43, 0x37, 0x6d, 0x0e, 0x7d, 0x89, 0x43, 0x27, 0x7d, 0xe8,
	0x23, 0xb6, 0x87, 0x03, 0xaa, 0xc6, 0x9f, 0x68, 0x51, 0x18, 0x88, 0x21, 0x7e, 0x22, 0x87, 0x45,
	0xa1, 0x08, 0x4f, 0x3f, 0x43, 0x35, 0x98, 0x76, 0x1e, 0xa0, 0xd6, 0x5e, 0xc5, 0x4e, 0x13, 0xbb,
	0x98, 0x68, 0xdf, 0x54, 0xc2, 0x17, 0x5c, 0x0a, 0xc4, 0xf4, 0x05, 0xa1, 0x92, 0xfa, 0x08, 0x1c,
	0x0d, 0x9f, 0xa2, 0x25, 0x7b, 0x8a, 0xa3, 0x6f, 0x8a, 0xa3, 0xa3, 0xe5, 0x3b, 0x5c, 0xdb, 0x29,
	0x56, 0x3f, 0x05, 0xc7, 0x22, 0xf6, 0x08, 0x76, 0x36, 0x2c, 0x03, 0xeb, 0xc8, 0x30, 0xec, 0x76,
	0xd3, 0xd5, 0xae, 0x72, 0xa3, 0xc7, 0xe3, 0x46, 0x97, 0xb9, 0x56, 0x81, 0x2b, 0x95, 0x46, 0xca,
	0x5a, 0x6d, 0x97, 0x34, 0xf5, 0x14, 0x80, 0xef, 0xda, 0x1a, 0xd1, 0x9e, 0x56, 0x42, 0x76, 0x79,
	0xbe, 0xbd, 0x44, 0x9d, 0xeb, 0xb9, 0xff, 0x42, 0x8d, 0x50, 0x40, 0xc5, 0xb6, 0x2b, 0x75, 0xac,
	0x57, 0x6a, 0x58, 0xfb, 0x56, 0x04, 0xf0, 0x00, 0x13, 0x3f, 0x70, 0xe9, 0x02, 0x05, 0x70, 0x9d,
	0x07, 0x6a, 0x58, 0x3d, 0x0e, 0x29, 0x54, 0x23, 0xda, 0xb7, 0xb9, 0x66, 0x9a, 0x99, 0x66, 0x46,
	0xa9, 0x58, 0x3d, 0x07, 0x93, 0xa8, 0x16, 0xab, 0xa7, 0x67, 0xb8, 0xe2, 0x21, 0x4f, 0x31, 0x5a,
	0x41, 0xe3, 0xa8, 0x16, 0xa9, 0x99, 0x12, 0x1c, 0xa6, 0xd0, 0xce, 0x2a, 0xf9, 0x0e, 0xc7, 0x1f,
	0xf5, 0xf0, 0x3b, 0xea, 0x62, 0x1a, 0xd5, 0x3a, 0x2b, 0x61, 0x06, 0xb2, 0x0d, 0xdc, 0x30, 0x90,
	0x51, 0xc5, 0xa6, 0xf6, 0x44, 0x3a, 0x2c, 0xd2, 0xc3, 0xbe, 0x94, 0x16, 0x29, 0x50, 0x51, 0x8b,
	0x30, 0xdd, 0xb0, 0x9b, 0x15, 0x5b, 0xaf, 0xe3, 0x0a, 0x32, 0x36, 0xf5, 0xaa, 0x4d, 0x5c, 0xed,
	0x75, 0x8e, 0x3b, 0xcc, 0x70, 0x34, 0xf5, 0x21, 0x96, 0x58, 0xb2, 0x09, 0x7d, 0xeb, 0x54, 0x23,
	0x2e, 0x52, 0x57, 0xe0, 0xa6, 0x98, 0x0d, 0x07, 0xb7, 0xea, 0x96, 0x81, 0x08, 0x76, 0xb5, 0x37,
	0xb8, 0xa5, 0x9b, 0x3b, 0x2c, 0x95, 0x03, 0x8d, 0xd2, 0x48, 0xf9, 0x68, 0xa3, 0x5b, 0x02, 0xf5,
	0x0e, 0xb7, 0xca, 0xb2, 0xf4, 0x66, 0xb4, 0x28, 0x54, 0xec, 0x65, 0x26, 0xdb, 0xf0, 0x1f, 0xc2,
	0xa2, 0x78, 0xef, 0xd7, 0x69, 0x06, 0xde, 0xea, 0x2c, 0x8a, 0xf7, 0x86, 0x65, 0x1c, 0x16, 0x25,
	0x14, 0xd1, 0x06, 0xa7, 0xb1, 0x49, 0xd6, 0xeb, 0xda, 0x2f, 0x32, 0x61, 0x83, 0xf3, 0x30, 0x95,
	0xd0, 0x06, 0x87, 0x25, 0xa9, 0x67, 0x60, 0x1c, 0xb5, 0x1d, 0xdb, 0x41, 0x3a, 0x57, 0xfd, 0x25,
	0x57, 0x9d, 0x62, 0x5e, 0x62, 0x09, 0x3e, 0x20, 0x87, 0xc2, 0x47, 0xf5, 0x0e, 0xc8, 0x18, 0xf5,
	0x36, 0x71, 0x1d, 0xeb, 0x31, 0xed, 0x57, 0x99, 0x30, 0x5a, 0xcf, 0x7b, 0x42, 0x1a, 0xad, 0xbe,
	0x02, 0xcb, 0x07, 0x72, 0x2c, 0xa4, 0xfd, 0x3a, 0x9a, 0x0f, 0x2a, 0x61, 0xf9, 0xa0, 0x3f, 0xd4,
	0x0f, 0x81, 0xd2, 0xc0, 0x0d, 0x9a, 0x83, 0x57, 0x33, 0x61, 0x0b, 0xfd, 0x30, 0x13, 0xd1, 0x16,
	0x9a, 0x27, 0x52, 0x35, 0xdb, 0x41, 0x46, 0x1d, 0x6b, 0xcf, 0x67, 0x43, 0xb5, 0xcb, 0x4c, 0x44,
	0xd5, 0x78, 0x22, 0xcd, 0x5e, 0xcb, 0x26, 0x6e, 0xc5, 0xc1, 0x44, 0xfb, 0x32, 0x84, 0xd9, 0x5b,
	0xf2, 0x84, 0x34, 0x7b, 0xbe, 0x82, 0x7a, 0x2f, 0x4c, 0x79, 0x55, 0x10, 0x60, 0xbe, 0xc2, 0x31,
	0x6a, 0x58, 0x0b, 0x11, 0xe4, 0x24, 0x8a, 0x49, 0x28, 0x4b, 0x2b, 0x0e, 0xc6, 0xcd, 0x56, 0xbd,
	0xdd, 0xd0, 0xbe, 0x0a, 0x91, 0xc0, 0xf3, 0xa5, 0x2c, 0xf0, 0xfc, 0x07, 0xd6, 0x6f, 0xd8, 0x46,
	0xcd, 0xb1, 0x91, 0x51, 0xd5, 0x9e, 0x8c, 0xe8, 0x9f, 0xf7, 0xa5, 0xac, 0xdf, 0xf0, 0x1f, 0x68,
	0x61, 0x1c, 0x6c, 0x92, 0xaa, 0xb5, 0xe6, 0x6a, 0x5f, 0x8b, 0x14, 0xa6, 0xec, 0x09, 0x69, 0x61,
	0x7c, 0x05, 0x5a, 0x41, 0x2d, 0x07, 0x13, 0xd7, 0xd6, 0xde, 0x81, 0xb0, 0x82, 0x96, 0x98, 0x88,
	0x56, 0x10, 0x4f, 0xa4, 0xc1, 0xef, 0x98, 0x2d, 0xed, 0x77, 0xb9, 0x30, 0xf8, 0xcb, 0x8b, 0x4b,
	0x34, 0xf8, 0x1d, 0xb3, 0x45, 0x1d, 0xe6, 0x60, 0xd3, 0x22, 0xda, 0xcb, 0xe3, 0xa1, 0xc3, 0xca,
	0x54, 0x42, 0x1d, 0xc6, 0x92, 0xd4, 0x45, 0x98, 0xf6, 0xba, 0x0b, 0x1a, 0x7b, 0x3a, 0xd7, 0x7f,
	0x85, 0xeb, 0x1f, 0x89, 0xf4, 0x2b, 0x34, 0xd5, 0x87, 0x1e, 0xc2, 0x1d, 0x32, 0x5a, 0x17, 0xa4,
	0x69, 0x5f, 0x59, 0xab, 0xa3, 0x1a, 0xd6, 0xae, 0x4e, 0x84, 0x75, 0xb1, 0xec, 0x4b, 0x69, 0x5d,
	0x04, 0x2a, 0x34, 0x8e, 0xc8, 0x7a, 0x9d, 0xb5, 0x2d, 0xd8, 0xd1, 0xbe, 0x38, 0x19, 0x01, 0x3c,
	0xfa, 0xd0, 0x32, 0x93, 0x32, 0xc0, 0x7a, 0x9d, 0x3f, 0xd0, 0x82, 0x12, 0x52, 0xd5, 0xfe, 0x3e,
	0x19, 0x16, 0x74, 0x79, 0xb9, 0x44, 0x0b, 0x4a, 0x48, 0x95, 0xd6, 0x16, 0xd9, 0x5c, 0x45, 0x04,
	0x6b, 0xaf, 0x4e, 0x85, 0xb5, 0xb5, 0xcc, 0x44, 0xb4, 0xb6, 0x78, 0x22, 0xed, 0x9c, 0xf8, 0x2f,
	0xdd, 0x5a, 0xd7, 0x7e, 0x33, 0x15, 0xba, 0x80, 0x6b, 0x3e, 0xf8, 0x28, 0x75, 0x01, 0xd7, 0x78,
	0x70, 0x9d, 0xfa, 0xcb, 0xc5, 0x0e, 0x32, 0x91, 0x8b, 0xb4, 0x1f, 0x1e, 0x0a, 0x95, 0x57, 0x3c,
	0x21, 0x55, 0xf6, 0x15, 0x16, 0x8c, 0xff, 0xbe, 0xb3, 0x9d, 0x5e, 0xf9, 0xe9, 0xb5, 0xed, 0xf4,
	0xe5, 0xa7, 0xaf, 0x6d, 0xa7, 0x3f, 0xe0, 0xae, 0xe9, 0xf8, 0x31, 0xd4, 0x68, 0xd5, 0x31, 0x39,
	0xe5, 0x78, 0xa3, 0x17, 0xdd, 0xff, 0x31, 0xe3, 0x3e, 0xe6, 0x3e, 0x7b, 0x6d, 0x3b, 0x7d, 0x6b,
	0x57, 0x2d, 0x6a, 0x4f, 0x0f, 0x15, 0xa9, 0x61, 0xf9, 0xbb, 0xd7, 0xb6, 0xd3, 0xa3, 0xc5, 0x63,
	0x94, 0x41, 0xde, 0x48, 0x68, 0xf2, 0xd9, 0x77, 0xb6, 0xd3, 0x59, 0xfa, 0x47, 0x6a, 0xa2, 0x06,
	0x3e, 0xf1, 0x63, 0x09, 0x14, 0x3e, 0x10, 0x52, 0x8f, 0xc3, 0x98, 0x65, 0x6a, 0x8f, 0x3f, 0x4e,
	0x87, 0x32, 0xd9, 0x22, 0xbc, 0x4d, 0x0d, 0x3c, 0x4f, 0x0d, 0x94, 0xc7, 0x2c, 0x53, 0xbd, 0x1d,
	0x18, 0x40, 0xfb, 0xac, 0x97, 0x7e, 0x24, 0x4c, 0x67, 0xbf, 0x5e, 0x66, 0x9a, 0x4c, 0x47, 0xbd,
	0x03, 0xd2, 0x55, 0x8c, 0xea, 0x6e, 0x75, 0x53, 0xfb, 0x1c, 0x53, 0xcf, 0x14, 0xa7, 0xb6, 0x0a,
	0x63, 0xf7, 0x8f, 0x46, 0x6c, 0xfa, 0x1a, 0xea, 0x45, 0x90, 0x5c, 0x54, 0x21, 0xda, 0xe7, 0x1f,
	0x1f, 0xbb, 0x25, 0x75, 0x5b, 0x6e, 0x2e, 0xc3, 0x18, 0x8b, 0x2c, 0xa7, 0xf8, 0xe1, 0xf8, 0x2b,
	0xb2, 0x6f, 0x5e, 0xdb, 0x4e, 0x33, 0x5d, 0xf6, 0xf4, 0x36, 0x7d, 0x5a, 0x41, 0x15, 0x52, 0x66,
	0x32, 0xb5, 0x08, 0x80, 0x0c, 0x03, 0x13, 0xa2, 0xd7, 0xf0, 0xa6, 0x36, 0xca, 0x32, 0xf9, 0x41,
	0xfa, 0xd6, 0x91, 0x6e, 0x39, 0x65, 0xbf, 0x5e, 0xbb, 0xb6, 0x9d, 0xa6, 0xbd, 0x28, 0x83, 0x5d,
	0xc2, 0x9b, 0xea, 0x65, 0x98, 0x26, 0xd8, 0x70, 0xb0, 0xab, 0x47, 0x4c, 0x8d, 0xf5, 0x6e, 0x6a,
	0x8a, 0xa3, 0x0b, 0x81, 0xc1, 0x7b, 0x40, 0xb1, 0xdb, 0x6e, 0xab, 0xed, 0x6a, 0xa9, 0xde, 0xad,
	0x78, 0x10, 0xb5, 0x04, 0x13, 0x2d, 0xdb, 0x71, 0x75, 0x7b, 0x03, 0x3b, 0x8e, 0x65, 0x62, 0x8d,
	0x0e, 0xdb, 0xe4, 0xde, 0x6c, 0x8c, 0x53, 0xe4, 0x65, 0x0f, 0xa8, 0x3e, 0x08, 0x8a, 0x83, 0x2b,
	0x96, 0xdd, 0xd4, 0x64, 0x96, 0x8d, 0xfc, 0x56, 0x21, 0xb7, 0x90, 0x6d, 0x93, 0x93, 0x18, 0x11,
	0xf7, 0x64, 0x7e, 0x37, 0x83, 0x23, 0xd1, 0x4c, 0x71, 0x03, 0x0b, 0x10, 0x12, 0xeb, 0xc4, 0x33,
	0x12, 0x64, 0xfc, 0xb1, 0xf1, 0x7e, 0xa7, 0xcf, 0x22, 0xe4, 0x5a, 0x8e, 0xb5, 0x81, 0x5c, 0x9c,
	0x94, 0x3f, 0xe0, 0xe1, 0xa8, 0xbf, 0x3f, 0x06, 0xe9, 0x96, 0x63, 0x7f, 0x1a, 0x1b, 0x6e, 0x12,
	0xda, 0xf8, 0x98, 0x9d, 0x1e, 0x4f, 0xf5, 0xeb, 0xf1, 0xfb, 0x20, 0x83, 0x9b, 0x66, 0xcb, 0xb6,
	0x9a, 0x2e, 0xa3, 0x4d, 0x8f, 0x39, 0x09, 0x40, 0xd4, 0x40, 0x9b, 0x60, 0x87, 0x39, 0x4d, 0xbe,
	0xbe, 0x81, 0x28, 0x4d, 0x02, 0x50, 0x8c, 0x28, 0xff, 0x90, 0x20, 0x1b, 0x4c, 0x8b, 0xf6, 0x3b,
	0x53, 0xee, 0x83, 0x0c, 0x1d, 0xc6, 0xb1, 0x4c, 0x26, 0xa0, 0x49, 0x00, 0x8a, 0x55, 0x6d, 0x02,
	0x96, 0x04, 0x20, 0x6a, 0xa0, 0x85, 0x08, 0xb9, 0x62, 0x3b, 0x66, 0x92, 0x76, 0x25, 0x00, 0x0d,
	0xb1, 0x65, 0xb9, 0x1f, 0x24, 0xfa, 0xcc, 0x28, 0x22, 0x17, 0xef, 0xdc, 0x2a, 0x28, 0x0b, 0xd2,
	0xb9, 0xd9, 0xd3, 0x73, 0xbd, 0x70, 0x85, 0x21, 0xd5, 0x8b, 0x30, 0xee, 0xd6, 0x89, 0xee, 0xe0,
	0xf5, 0xb6, 0xe5, 0x60, 0x53, 0x53, 0x98, 0x1b, 0x7b, 0x22, 0x5b, 0xce, 0xad, 0x93, 0xb2, 0x87,
	0x8b, 0xf1, 0xed, 0x29, 0x09, 0x64, 0x36, 0xb5, 0x7e, 0xdf, 0x73, 0x6d, 0x87, 0xa7, 0xc7, 0x06,
	0x68, 0x51, 0x02, 0xd6, 0xa6, 0xfa, 0x68, 0x10, 0x62, 0xac, 0x95, 0x12, 0x18, 0x08, 0x58, 0xdb,
	0x8d, 0x6b, 0x67, 0x67, 0xcf, 0xf6, 0xce, 0xb5, 0x18, 0x47, 0x7e, 0x20, 0x41, 0xc6, 0x5f, 0x56,
	0x11, 0x63, 0x9f, 0xbd, 0x19, 0xfb, 0x78, 0x83, 0x8e, 0x24, 0x63, 0x1f, 0x0e, 0x19, 0xbc, 0xff,
	0xda, 0x41, 0x7c, 0xb9, 0x4f, 0xe2, 0xef, 0x20, 0x8d, 0xbf, 0xba, 0xb6, 0xdf, 0x49, 0x13, 0xfa,
	0x67, 0x34, 0xb9, 0x7f, 0xfa, 0x61, 0xcb, 0xc8, 0xf5, 0xd8, 0x12, 0x75, 0x78, 0x92, 0xe6, 0x25,
	0x70, 0x78, 0x3c, 0x06, 0x12, 0x34, 0x30, 0x91, 0x18, 0xd8, 0x1b, 0xd2, 0xbc, 0x25, 0x41, 0xda,
	0x9b, 0x0e, 0x8b, 0xb1, 0xcf, 0x41, 0x1f, 0xfb, 0xcc, 0xcd, 0xce, 0xbe, 0xb7, 0x63, 0x9f, 0x9f,
	0xc9, 0x30, 0x11, 0x5b, 0xa2, 0xdf, 0xef, 0x9c, 0x3b, 0x03, 0xa9, 0xb6, 0x53, 0x4f, 0x42, 0x37,
	0xaa, 0xaf, 0xae, 0xc0, 0x21, 0x9e, 0x13, 0xa3, 0x8a, 0x8d, 0x9a, 0xde, 0x42, 0x6e, 0xd5, 0x63,
	0xdc, 0x47, 0xb6, 0x0a, 0xa9, 0x85, 0xd1, 0x53, 0x3d, 0x75, 0x6a, 0x11, 0x13, 0x4b, 0xc8, 0xad,
	0xde, 0x00, 0xa3, 0xa0, 0x25, 0x98, 0xae, 0x62, 0x64, 0x62, 0x87, 0xe8, 0xab, 0x75, 0x64, 0xd4,
	0xea, 0x16, 0x71, 0x93, 0xcc, 0xd0, 0x0e, 0x79, 0xe8, 0xa2, 0x0f, 0xa6, 0x2c, 0x34, 0xf1, 0x1a,
	0x6a, 0xd7, 0x5d, 0x5e, 0x4b, 0x4a, 0xef, 0xc6, 0x72, 0x1e, 0x90, 0xd5, 0x4d, 0x01, 0xb2, 0xa4,
	0xbd, 0x6a, 0xda, 0x0d, 0x64, 0x35, 0xb5, 0x74, 0x68, 0x64, 0xf4, 0xdd, 0x1a, 0xe0, 0x00, 0x15,
	0x23, 0xf2, 0x2b, 0x12, 0x40, 0xf8, 0xc1, 0x48, 0xb0, 0x78, 0x88, 0x2c, 0xee, 0xca, 0xa1, 0xd4,
	0x30, 0x39, 0x24, 0x0d, 0x83, 0x43, 0xf2, 0xc0, 0x1c, 0xfa, 0x82, 0x0c, 0x19, 0xff, 0x13, 0xa2,
	0x60, 0xd0, 0x10, 0x19, 0xb4, 0x08, 0x39, 0xd4, 0x76, 0xab, 0x3a, 0x27, 0x42, 0x92, 0x9e, 0x18,
	0x28, 0xae, 0xc4, 0x60, 0xdd, 0x79, 0x28, 0x0d, 0x93, 0x87, 0xf2, 0x30, 0x78, 0xa8, 0x0c, 0xcc,
	0xc3, 0x7f, 0x2a, 0x00, 0xe1, 0x87, 0x60, 0x31, 0x0a, 0xf4, 0x46, 0x4e, 0x7c, 0x31, 0xe2, 0x8e,
	0xad, 0x82, 0xbc, 0x90, 0x3a, 0x7d, 0x7a, 0xbe, 0x17, 0x23, 0x7c, 0xe0, 0xf4, 0x09, 0x38, 0x6a,
	0x60, 0xc7, 0xb5, 0xd6, 0x2c, 0x03, 0xb9, 0x98, 0x7d, 0xa1, 0xb6, 0x1d, 0xcb, 0xdd, 0x4c, 0xd2,
	0x88, 0x1d, 0x89, 0x58, 0x28, 0xf8, 0x06, 0x54, 0x0b, 0xfe, 0xbf, 0xab, 0x65, 0x7d, 0xcd, 0xaa,
	0x63, 0x56, 0xe2, 0x04, 0xfc, 0x3c, 0xde, 0xed, 0x15, 0x17, 0x3d, 0x43, 0x6a, 0x19, 0x54, 0xa3,
	0x6e, 0xe1, 0xa6, 0xab, 0x47, 0xd4, 0x92, 0x30, 0x76, 0x9a, 0xc3, 0xcf, 0x87, 0x68, 0xd5, 0x80,
	0xff, 0xdb, 0x69, 0x33, 0xcc, 0x7b, 0x82, 0xae, 0xfd, 0xe6, 0x1d, 0xc6, 0x83, 0x8c, 0x17, 0x01,
	0xbc, 0x97, 0xd0, 0xa9, 0x56, 0x3a, 0xc1, 0x54, 0x8b, 0xc3, 0xe8, 0x54, 0x6b, 0x19, 0x0e, 0x87,
	0x36, 0xc2, 0x0c, 0x66, 0x12, 0x97, 0xfe, 0x12, 0x0e, 0x6a, 0x34, 0x16, 0x72, 0x7f, 0x49, 0xc1,
	0xe1, 0x2e, 0x1b, 0x3a, 0x44, 0xec, 0x0d, 0x1a, 0x7b, 0x09, 0x86, 0xc0, 0xa3, 0x83, 0x0e, 0x81,
	0xbb, 0x4e, 0xe1, 0x62, 0x6e, 0x7e, 0x3a, 0x05, 0xda, 0x6e, 0x5b, 0x6c, 0x84, 0xaf, 0x07, 0xf5,
	0xf5, 0x39, 0x90, 0x5d, 0xbb, 0x86, 0x13, 0x2d, 0xe1, 0x71, 0x44, 0xcc, 0x49, 0xff, 0x91, 0x21,
	0x1b, 0x6c, 0x5c, 0x3a, 0x00, 0x5e, 0x09, 0x56, 0xaa, 0x46, 0xfb, 0x59, 0x9a, 0x8c, 0xaf, 0x54,
	0x8d, 0xf5, 0xb5, 0x52, 0xd5, 0x75, 0xfd, 0x2d, 0x35, 0xc0, 0xfa, 0xdb, 0xae, 0x3d, 0x6a, 0x82,
	0x08, 0xed, 0xb7, 0x47, 0x95, 0x87, 0xd5, 0xa3, 0x86, 0x4b, 0x9a, 0x4a, 0xf2, 0x25, 0xcd, 0x8b,
	0x30, 0xce, 0xf6, 0x2c, 0x61, 0x47, 0x67, 0xb9, 0x4a, 0xf7, 0x6e, 0x22, 0xe7, 0x01, 0x1f, 0xe9,
	0xec, 0x84, 0x9e, 0x94, 0x21, 0x1b, 0x6c, 0xc0, 0x7b, 0xdf, 0x13, 0x7f, 0x57, 0x8e, 0x8d, 0xed,
	0x3d, 0xc7, 0x52, 0xc3, 0xe2, 0xd8, 0x32, 0x1c, 0xee, 0xd8, 0xdb, 0xd8, 0xcb, 0x82, 0x73, 0xb4,
	0x08, 0xd3, 0x24, 0xd6, 0x4b, 0xd1, 0xe8, 0x33, 0xe1, 0x78, 0x17, 0xa3, 0x7d, 0x45, 0xc8, 0xcd,
	0x3b, 0xac, 0x77, 0x1d, 0x1e, 0xbd, 0xa1, 0x40, 0xaa, 0x70, 0x20, 0x1a, 0x63, 0x31, 0x15, 0x11,
	0x53, 0x91, 0x1b, 0x7b, 0x2a, 0xf2, 0xfb, 0x14, 0x8c, 0x47, 0xf7, 0x4c, 0x8b, 0xa0, 0x3b, 0x58,
	0x73, 0x90, 0xaf, 0xa7, 0x60, 0x7a, 0xc7, 0x9e, 0x76, 0xe1, 0xe4, 0x1b, 0x64, 0xf2, 0x71, 0x35,
	0x05, 0xd9, 0xe0, 0xc4, 0x80, 0xd8, 0x10, 0x34, 0xb4, 0x0d, 0x41, 0x05, 0xcf, 0xbf, 0x7c, 0x8f,
	0xe2, 0xc9, 0xad, 0x42, 0x7a, 0x41, 0xce, 0xe7, 0xe7, 0xf2, 0xf9, 0xfe, 0xf6, 0xe3, 0x3c, 0xa1,
	0xc0, 0x54, 0xc7, 0x01, 0x0d, 0xe1, 0x2c, 0x98, 0x60, 0xab, 0xec, 0x26, 0x72, 0x11, 0xdb, 0xa7,
	0x9e, 0x60, 0xa0, 0x3c, 0x4e, 0x91, 0x8b, 0x1e, 0x70, 0xb8, 0x3b, 0x4b, 0x83, 0xa6, 0x57, 0x1a,
	0xf4, 0x0b, 0xa8, 0xdc, 0xcf, 0x17, 0x50, 0x9f, 0x78, 0x4a, 0x84, 0x78, 0x73, 0x77, 0xcf, 0xe6,
	0xef, 0xee, 0xfd, 0xc3, 0xfb, 0x22, 0xe4, 0xa2, 0x27, 0x6b, 0x12, 0x8c, 0x1b, 0xc0, 0x09, 0x4f,
	0xd8, 0x74, 0x7e, 0xbe, 0xcf, 0x0c, 0xe1, 0xf3, 0xfd, 0xdf, 0x14, 0x38, 0xda, 0xf5, 0x74, 0x91,
	0x08, 0x06, 0x11, 0x0c, 0x37, 0x42, 0x30, 0x8c, 0xee, 0x12, 0x0c, 0x9f, 0x04, 0xd5, 0xb0, 0x9b,
	0x4d, 0x6c, 0xb8, 0xba, 0x1b, 0x9c, 0x5b, 0xf3, 0x42, 0x82, 0x67, 0x6b, 0x0d, 0xd5, 0x09, 0xee,
	0xe9, 0xb3, 0x9e, 0x67, 0x68, 0xc5, 0x3f, 0xce, 0xb6, 0x23, 0xd2, 0xb2, 0x43, 0x88, 0xb4, 0x17,
	0x64, 0xc8, 0x06, 0xc7, 0xef, 0x44, 0x74, 0x89, 0xe8, 0xda, 0x9b, 0xe8, 0xda, 0x8b, 0x4e, 0xe2,
	0x8f, 0xfe, 0x58, 0x29, 0x72, 0xdc, 0x53, 0x10, 0x58, 0x10, 0x58, 0x74, 0x0f, 0xc3, 0xeb, 0x1e,
	0xfe, 0x24, 0x81, 0xcc, 0x4f, 0x3b, 0x8b, 0x89, 0xfc, 0x7b, 0xbd, 0x67, 0xf7, 0x3e, 0xc8, 0x04,
	0x61, 0x9d, 0x64, 0xb5, 0xc6, 0xdc, 0x35, 0xa4, 0xe5, 0x41, 0x37, 0xfd, 0x2a, 0x91, 0x4d, 0xbf,
	0xf3, 0xf3, 0xb3, 0x77, 0xf5, 0x37, 0xe9, 0x7d, 0x5d, 0x82, 0x5c, 0xe4, 0x9c, 0xbd, 0xa0, 0x9a,
	0xa0, 0xda, 0x5e, 0x51, 0xed, 0xaf, 0x12, 0x64, 0xfc, 0xfb, 0x19, 0x04, 0xcf, 0x04, 0xcf, 0xf6,
	0x8a, 0x67, 0xac, 0xdf, 0x64, 0x97, 0x7a, 0x08, 0x92, 0x09, 0x92, 0xed, 0x11, 0xc9, 0xfe, 0x2c,
	0x81, 0xc2, 0x6f, 0x87, 0x11, 0x2c, 0x13, 0x2c, 0xdb, 0x2b, 0x96, 0x3d, 0x27, 0x83, 0xc2, 0x2f,
	0x17, 0x12, 0x2c, 0xdb, 0xff, 0x2c, 0xeb, 0x76, 0x5c, 0x2f, 0x7f, 0x66, 0x2e, 0xdf, 0xfb, 0x07,
	0xc9, 0x1d, 0x3c, 0x55, 0xfa, 0xe5, 0x69, 0xe7, 0x84, 0x35, 0x3d, 0x84, 0x09, 0xeb, 0x8f, 0x64,
	0xc8, 0x04, 0xb7, 0x52, 0x09, 0xbe, 0x8a, 0x56, 0xf1, 0xba, 0xad, 0xe2, 0x99, 0xd3, 0xf3, 0x09,
	0x2e, 0xe9, 0x58, 0x82, 0x69, 0x3f, 0x1b, 0xe1, 0x02, 0x5b, 0x02, 0xd2, 0x1e, 0xf2, 0xd1, 0xfe,
	0x22, 0x5b, 0x8c, 0xb9, 0x2f, 0xc9, 0x30, 0x19, 0xbf, 0x67, 0x4d, 0xf0, 0x57, 0xf0, 0x77, 0xff,
	0xf0, 0xf7, 0x05, 0x19, 0xb2, 0xc1, 0x6d, 0x7f, 0x82, 0xba, 0x82, 0xba, 0xfb, 0x8b, 0xba, 0xc1,
	0xc5, 0x93, 0x82, 0xba, 0x82, 0xba, 0xfb, 0x87, 0xba, 0x74, 0xbc, 0xeb, 0x5f, 0x82, 0x2a, 0x98,
	0x2b, 0x98, 0xfb, 0xae, 0xcc, 0x3d, 0x77, 0xa3, 0x30, 0xf7, 0x39, 0x19, 0x94, 0x25, 0xff, 0x26,
	0xde, 0xf7, 0x3d, 0x6f, 0x03, 0xda, 0x8d, 0x0d, 0x4a, 0xbb, 0xd4, 0x50, 0x68, 0x37, 0xd4, 0xfb,
	0x80, 0xce, 0xce, 0x9e, 0x4d, 0x70, 0x1f, 0x50, 0x34, 0x8a, 0x95, 0x7e, 0xf6, 0x0b, 0xec, 0xc5,
	0xba, 0xc2, 0x37, 0x24, 0x48, 0x95, 0x17, 0x97, 0x04, 0x55, 0x0f, 0xf8, 0xd5, 0x55, 0xf3, 0xf3,
	0x67, 0xcf, 0xf5, 0xb7, 0x4e, 0xfa, 0x87, 0x14, 0xc8, 0xfc, 0x42, 0x6f, 0xb1, 0x09, 0x69, 0x88,
	0xd7, 0x6d, 0xf6, 0x4a, 0x96, 0xeb, 0xdf, 0x96, 0x29, 0x45, 0x5c, 0x7c, 0xd7, 0xfc, 0xdd, 0x7d,
	0xba, 0xf8, 0x45, 0x09, 0x0e, 0x75, 0x5e, 0xe9, 0x2e, 0xbc, 0x7d, 0x80, 0xbc, 0xad, 0x5e, 0xee,
	0xe8, 0x3a, 0x64, 0xe6, 0x05, 0x6e, 0xc9, 0x75, 0xda, 0x78, 0xb0, 0x0d, 0x8b, 0x12, 0x64, 0x83,
	0x3b, 0xfd, 0x45, 0x4f, 0xb2, 0xff, 0x07, 0xeb, 0xf7, 0x80, 0x42, 0x8c, 0x2a, 0x6e, 0xa0, 0x77,
	0xdb, 0x96, 0x18, 0x3b, 0x69, 0xcf, 0x21, 0xc3, 0xfb, 0x8e, 0x12, 0xe3, 0xd8, 0xbf, 0x65, 0xc8,
	0x06, 0xff, 0x06, 0x42, 0x70, 0x4c, 0x4c, 0x08, 0xc3, 0xe6, 0x35, 0x64, 0x6b, 0x82, 0x51, 0xb5,
	0xcf, 0x56, 0xbf, 0x69, 0x4d, 0x47, 0xbf, 0x1b, 0x9e, 0x9e, 0x9f, 0x1f, 0x70, 0x36, 0x99, 0x19,
	0xd6, 0x6c, 0xf2, 0xfb, 0x12, 0xa4, 0x96, 0x97, 0x4b, 0x82, 0xf1, 0x83, 0x32, 0xfe, 0xde, 0xd8,
	0x81, 0xc6, 0xdb, 0xb7, 0x0a, 0xd2, 0xc2, 0xd8, 0xdc, 0x5c, 0xef, 0x9f, 0x87, 0x8b, 0x00, 0xad,
	0xf6, 0x6a, 0xdd, 0x32, 0x3a, 0x2f, 0x84, 0xb8, 0xfe, 0xa5, 0x71, 0xa3, 0xe5, 0x2c, 0x87, 0x5d,
	0xc2, 0x9b, 0xea, 0xc7, 0x61, 0x8a, 0x71, 0x7e, 0xcd, 0x76, 0xae, 0x20, 0xc7, 0xb4, 0x9a, 0x15,
	0xaf, 0x23, 0x4e, 0xb8, 0x47, 0x7a, 0x92, 0x5a, 0xb9, 0x18, 0x18, 0x89, 0x5f, 0x99, 0x24, 0x81,
	0xc2, 0xff, 0x75, 0x8d, 0xe0, 0xcc, 0xa0, 0x9c, 0x19, 0xde, 0x59, 0x81, 0x6e, 0x23, 0xb8, 0xb9,
	0xbb, 0xe6, 0xcf, 0x26, 0x5a, 0x3d, 0x18, 0xe8, 0xb0, 0x40, 0xfc, 0xd4, 0xb4, 0x04, 0x19, 0xff,
	0xff, 0x1b, 0x09, 0x9a, 0x08, 0x9a, 0x5c, 0x87, 0x26, 0xfe, 0x7f, 0xb6, 0x12, 0x34, 0x39, 0xe0,
	0x2b, 0x44, 0xf9, 0xd9, 0xb9, 0x33, 0xfd, 0x2d, 0x1f, 0xcc, 0x82, 0x44, 0x1d, 0xa2, 0xaa, 0x1e,
	0x07, 0x58, 0xf5, 0x7a, 0xbe, 0x3e, 0x02, 0xf2, 0x06, 0xaa, 0xb7, 0xbd, 0x2a, 0x2b, 0xf3, 0x87,
	0xe2, 0x29, 0x38, 0x6e, 0xd8, 0x8d, 0x19, 0xe2, 0x3a, 0x76, 0xb3, 0x62, 0x36, 0x66, 0x50, 0xcb,
	0xa2, 0x6e, 0x6d, 0xd5, 0xdb, 0x8d, 0x55, 0xab, 0x59, 0x29, 0x4e, 0x2d, 0xf2, 0xff, 0x17, 0xbb,
	0xe4, 0x09, 0x56, 0x15, 0xf6, 0x7f, 0x5f, 0xe7, 0xff, 0x17, 0x00, 0x00, 0xff, 0xff, 0xbf, 0x03,
	0x51, 0xff, 0x49, 0x76, 0x00, 0x00,
}
