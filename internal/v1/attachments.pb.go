// Code generated by protoc-gen-go. DO NOT EDIT.
// source: attachments.proto

package v1

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	_ "github.com/grpc-ecosystem/grpc-gateway/protoc-gen-swagger/options"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// AttachmentCreateRequest specifies what kind of Attachments should be registered in
// the organizations fleet.
type AttachmentCreateRequest struct {
	// Reserved for future use.
	Meta *CreateRequestMetadata `protobuf:"bytes,1,opt,name=meta,proto3" json:"meta,omitempty"`
	// Parameters to define the new Attachment.
	Attachment           *Attachment `protobuf:"bytes,2,opt,name=attachment,proto3" json:"attachment,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *AttachmentCreateRequest) Reset()         { *m = AttachmentCreateRequest{} }
func (m *AttachmentCreateRequest) String() string { return proto.CompactTextString(m) }
func (*AttachmentCreateRequest) ProtoMessage()    {}
func (*AttachmentCreateRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_1a97d0ef1337fe45, []int{0}
}

func (m *AttachmentCreateRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AttachmentCreateRequest.Unmarshal(m, b)
}
func (m *AttachmentCreateRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AttachmentCreateRequest.Marshal(b, m, deterministic)
}
func (m *AttachmentCreateRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AttachmentCreateRequest.Merge(m, src)
}
func (m *AttachmentCreateRequest) XXX_Size() int {
	return xxx_messageInfo_AttachmentCreateRequest.Size(m)
}
func (m *AttachmentCreateRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AttachmentCreateRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AttachmentCreateRequest proto.InternalMessageInfo

func (m *AttachmentCreateRequest) GetMeta() *CreateRequestMetadata {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *AttachmentCreateRequest) GetAttachment() *Attachment {
	if m != nil {
		return m.Attachment
	}
	return nil
}

// AttachmentCreateResponse reports how the Attachments were created in the system.
type AttachmentCreateResponse struct {
	// Reserved for future use.
	Meta *CreateResponseMetadata `protobuf:"bytes,1,opt,name=meta,proto3" json:"meta,omitempty"`
	// The created Attachment.
	Attachment *Attachment `protobuf:"bytes,2,opt,name=attachment,proto3" json:"attachment,omitempty"`
	// Rate limit information.
	RateLimit            *RateLimitMetadata `protobuf:"bytes,3,opt,name=rate_limit,json=rateLimit,proto3" json:"rate_limit,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *AttachmentCreateResponse) Reset()         { *m = AttachmentCreateResponse{} }
func (m *AttachmentCreateResponse) String() string { return proto.CompactTextString(m) }
func (*AttachmentCreateResponse) ProtoMessage()    {}
func (*AttachmentCreateResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_1a97d0ef1337fe45, []int{1}
}

func (m *AttachmentCreateResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AttachmentCreateResponse.Unmarshal(m, b)
}
func (m *AttachmentCreateResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AttachmentCreateResponse.Marshal(b, m, deterministic)
}
func (m *AttachmentCreateResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AttachmentCreateResponse.Merge(m, src)
}
func (m *AttachmentCreateResponse) XXX_Size() int {
	return xxx_messageInfo_AttachmentCreateResponse.Size(m)
}
func (m *AttachmentCreateResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AttachmentCreateResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AttachmentCreateResponse proto.InternalMessageInfo

func (m *AttachmentCreateResponse) GetMeta() *CreateResponseMetadata {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *AttachmentCreateResponse) GetAttachment() *Attachment {
	if m != nil {
		return m.Attachment
	}
	return nil
}

func (m *AttachmentCreateResponse) GetRateLimit() *RateLimitMetadata {
	if m != nil {
		return m.RateLimit
	}
	return nil
}

// AttachmentGetRequest specifies which Attachment to retrieve.
type AttachmentGetRequest struct {
	// Reserved for future use.
	Meta *GetRequestMetadata `protobuf:"bytes,1,opt,name=meta,proto3" json:"meta,omitempty"`
	// The unique identifier of the Attachment to retrieve.
	Id                   string   `protobuf:"bytes,2,opt,name=id,proto3" json:"id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AttachmentGetRequest) Reset()         { *m = AttachmentGetRequest{} }
func (m *AttachmentGetRequest) String() string { return proto.CompactTextString(m) }
func (*AttachmentGetRequest) ProtoMessage()    {}
func (*AttachmentGetRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_1a97d0ef1337fe45, []int{2}
}

func (m *AttachmentGetRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AttachmentGetRequest.Unmarshal(m, b)
}
func (m *AttachmentGetRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AttachmentGetRequest.Marshal(b, m, deterministic)
}
func (m *AttachmentGetRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AttachmentGetRequest.Merge(m, src)
}
func (m *AttachmentGetRequest) XXX_Size() int {
	return xxx_messageInfo_AttachmentGetRequest.Size(m)
}
func (m *AttachmentGetRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AttachmentGetRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AttachmentGetRequest proto.InternalMessageInfo

func (m *AttachmentGetRequest) GetMeta() *GetRequestMetadata {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *AttachmentGetRequest) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

// AttachmentGetResponse returns a requested Attachment.
type AttachmentGetResponse struct {
	// Reserved for future use.
	Meta *GetResponseMetadata `protobuf:"bytes,1,opt,name=meta,proto3" json:"meta,omitempty"`
	// The requested Attachment.
	Attachment *Attachment `protobuf:"bytes,2,opt,name=attachment,proto3" json:"attachment,omitempty"`
	// Rate limit information.
	RateLimit            *RateLimitMetadata `protobuf:"bytes,3,opt,name=rate_limit,json=rateLimit,proto3" json:"rate_limit,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *AttachmentGetResponse) Reset()         { *m = AttachmentGetResponse{} }
func (m *AttachmentGetResponse) String() string { return proto.CompactTextString(m) }
func (*AttachmentGetResponse) ProtoMessage()    {}
func (*AttachmentGetResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_1a97d0ef1337fe45, []int{3}
}

func (m *AttachmentGetResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AttachmentGetResponse.Unmarshal(m, b)
}
func (m *AttachmentGetResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AttachmentGetResponse.Marshal(b, m, deterministic)
}
func (m *AttachmentGetResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AttachmentGetResponse.Merge(m, src)
}
func (m *AttachmentGetResponse) XXX_Size() int {
	return xxx_messageInfo_AttachmentGetResponse.Size(m)
}
func (m *AttachmentGetResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AttachmentGetResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AttachmentGetResponse proto.InternalMessageInfo

func (m *AttachmentGetResponse) GetMeta() *GetResponseMetadata {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *AttachmentGetResponse) GetAttachment() *Attachment {
	if m != nil {
		return m.Attachment
	}
	return nil
}

func (m *AttachmentGetResponse) GetRateLimit() *RateLimitMetadata {
	if m != nil {
		return m.RateLimit
	}
	return nil
}

// AttachmentDeleteRequest identifies a Attachment by ID to delete.
type AttachmentDeleteRequest struct {
	// Reserved for future use.
	Meta *DeleteRequestMetadata `protobuf:"bytes,1,opt,name=meta,proto3" json:"meta,omitempty"`
	// The unique identifier of the Attachment to delete.
	Id                   string   `protobuf:"bytes,2,opt,name=id,proto3" json:"id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AttachmentDeleteRequest) Reset()         { *m = AttachmentDeleteRequest{} }
func (m *AttachmentDeleteRequest) String() string { return proto.CompactTextString(m) }
func (*AttachmentDeleteRequest) ProtoMessage()    {}
func (*AttachmentDeleteRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_1a97d0ef1337fe45, []int{4}
}

func (m *AttachmentDeleteRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AttachmentDeleteRequest.Unmarshal(m, b)
}
func (m *AttachmentDeleteRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AttachmentDeleteRequest.Marshal(b, m, deterministic)
}
func (m *AttachmentDeleteRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AttachmentDeleteRequest.Merge(m, src)
}
func (m *AttachmentDeleteRequest) XXX_Size() int {
	return xxx_messageInfo_AttachmentDeleteRequest.Size(m)
}
func (m *AttachmentDeleteRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AttachmentDeleteRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AttachmentDeleteRequest proto.InternalMessageInfo

func (m *AttachmentDeleteRequest) GetMeta() *DeleteRequestMetadata {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *AttachmentDeleteRequest) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

// AttachmentDeleteResponse returns information about a Attachment that was deleted.
type AttachmentDeleteResponse struct {
	// Reserved for future use.
	Meta *DeleteResponseMetadata `protobuf:"bytes,1,opt,name=meta,proto3" json:"meta,omitempty"`
	// Rate limit information.
	RateLimit            *RateLimitMetadata `protobuf:"bytes,2,opt,name=rate_limit,json=rateLimit,proto3" json:"rate_limit,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *AttachmentDeleteResponse) Reset()         { *m = AttachmentDeleteResponse{} }
func (m *AttachmentDeleteResponse) String() string { return proto.CompactTextString(m) }
func (*AttachmentDeleteResponse) ProtoMessage()    {}
func (*AttachmentDeleteResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_1a97d0ef1337fe45, []int{5}
}

func (m *AttachmentDeleteResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AttachmentDeleteResponse.Unmarshal(m, b)
}
func (m *AttachmentDeleteResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AttachmentDeleteResponse.Marshal(b, m, deterministic)
}
func (m *AttachmentDeleteResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AttachmentDeleteResponse.Merge(m, src)
}
func (m *AttachmentDeleteResponse) XXX_Size() int {
	return xxx_messageInfo_AttachmentDeleteResponse.Size(m)
}
func (m *AttachmentDeleteResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AttachmentDeleteResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AttachmentDeleteResponse proto.InternalMessageInfo

func (m *AttachmentDeleteResponse) GetMeta() *DeleteResponseMetadata {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *AttachmentDeleteResponse) GetRateLimit() *RateLimitMetadata {
	if m != nil {
		return m.RateLimit
	}
	return nil
}

// AttachmentListRequest specifies criteria for retrieving a list of Attachments.
type AttachmentListRequest struct {
	// Paging parameters for the query.
	Meta *ListRequestMetadata `protobuf:"bytes,1,opt,name=meta,proto3" json:"meta,omitempty"`
	// A human-readable filter query string.
	Filter               string   `protobuf:"bytes,2,opt,name=filter,proto3" json:"filter,omitempty"`
	CompositeRoleId      string   `protobuf:"bytes,3,opt,name=composite_role_id,json=compositeRoleId,proto3" json:"composite_role_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AttachmentListRequest) Reset()         { *m = AttachmentListRequest{} }
func (m *AttachmentListRequest) String() string { return proto.CompactTextString(m) }
func (*AttachmentListRequest) ProtoMessage()    {}
func (*AttachmentListRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_1a97d0ef1337fe45, []int{6}
}

func (m *AttachmentListRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AttachmentListRequest.Unmarshal(m, b)
}
func (m *AttachmentListRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AttachmentListRequest.Marshal(b, m, deterministic)
}
func (m *AttachmentListRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AttachmentListRequest.Merge(m, src)
}
func (m *AttachmentListRequest) XXX_Size() int {
	return xxx_messageInfo_AttachmentListRequest.Size(m)
}
func (m *AttachmentListRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AttachmentListRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AttachmentListRequest proto.InternalMessageInfo

func (m *AttachmentListRequest) GetMeta() *ListRequestMetadata {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *AttachmentListRequest) GetFilter() string {
	if m != nil {
		return m.Filter
	}
	return ""
}

func (m *AttachmentListRequest) GetCompositeRoleId() string {
	if m != nil {
		return m.CompositeRoleId
	}
	return ""
}

// AttachmentListResponse returns a list of Attachments that meet the criteria of a
// AttachmentListRequest.
type AttachmentListResponse struct {
	// Paging information for the query.
	Meta *ListResponseMetadata `protobuf:"bytes,1,opt,name=meta,proto3" json:"meta,omitempty"`
	// A single page of results matching the list request criteria.
	Attachments []*Attachment `protobuf:"bytes,2,rep,name=attachments,proto3" json:"attachments,omitempty"`
	// Rate limit information.
	RateLimit            *RateLimitMetadata `protobuf:"bytes,3,opt,name=rate_limit,json=rateLimit,proto3" json:"rate_limit,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *AttachmentListResponse) Reset()         { *m = AttachmentListResponse{} }
func (m *AttachmentListResponse) String() string { return proto.CompactTextString(m) }
func (*AttachmentListResponse) ProtoMessage()    {}
func (*AttachmentListResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_1a97d0ef1337fe45, []int{7}
}

func (m *AttachmentListResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AttachmentListResponse.Unmarshal(m, b)
}
func (m *AttachmentListResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AttachmentListResponse.Marshal(b, m, deterministic)
}
func (m *AttachmentListResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AttachmentListResponse.Merge(m, src)
}
func (m *AttachmentListResponse) XXX_Size() int {
	return xxx_messageInfo_AttachmentListResponse.Size(m)
}
func (m *AttachmentListResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AttachmentListResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AttachmentListResponse proto.InternalMessageInfo

func (m *AttachmentListResponse) GetMeta() *ListResponseMetadata {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *AttachmentListResponse) GetAttachments() []*Attachment {
	if m != nil {
		return m.Attachments
	}
	return nil
}

func (m *AttachmentListResponse) GetRateLimit() *RateLimitMetadata {
	if m != nil {
		return m.RateLimit
	}
	return nil
}

type Attachment struct {
	// Unique identifier of the Attachment.
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	CompositeRoleId      string   `protobuf:"bytes,2,opt,name=composite_role_id,json=compositeRoleId,proto3" json:"composite_role_id,omitempty"`
	AttachedRoleId       string   `protobuf:"bytes,3,opt,name=attached_role_id,json=attachedRoleId,proto3" json:"attached_role_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Attachment) Reset()         { *m = Attachment{} }
func (m *Attachment) String() string { return proto.CompactTextString(m) }
func (*Attachment) ProtoMessage()    {}
func (*Attachment) Descriptor() ([]byte, []int) {
	return fileDescriptor_1a97d0ef1337fe45, []int{8}
}

func (m *Attachment) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Attachment.Unmarshal(m, b)
}
func (m *Attachment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Attachment.Marshal(b, m, deterministic)
}
func (m *Attachment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Attachment.Merge(m, src)
}
func (m *Attachment) XXX_Size() int {
	return xxx_messageInfo_Attachment.Size(m)
}
func (m *Attachment) XXX_DiscardUnknown() {
	xxx_messageInfo_Attachment.DiscardUnknown(m)
}

var xxx_messageInfo_Attachment proto.InternalMessageInfo

func (m *Attachment) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Attachment) GetCompositeRoleId() string {
	if m != nil {
		return m.CompositeRoleId
	}
	return ""
}

func (m *Attachment) GetAttachedRoleId() string {
	if m != nil {
		return m.AttachedRoleId
	}
	return ""
}

func init() {
	proto.RegisterType((*AttachmentCreateRequest)(nil), "v1.AttachmentCreateRequest")
	proto.RegisterType((*AttachmentCreateResponse)(nil), "v1.AttachmentCreateResponse")
	proto.RegisterType((*AttachmentGetRequest)(nil), "v1.AttachmentGetRequest")
	proto.RegisterType((*AttachmentGetResponse)(nil), "v1.AttachmentGetResponse")
	proto.RegisterType((*AttachmentDeleteRequest)(nil), "v1.AttachmentDeleteRequest")
	proto.RegisterType((*AttachmentDeleteResponse)(nil), "v1.AttachmentDeleteResponse")
	proto.RegisterType((*AttachmentListRequest)(nil), "v1.AttachmentListRequest")
	proto.RegisterType((*AttachmentListResponse)(nil), "v1.AttachmentListResponse")
	proto.RegisterType((*Attachment)(nil), "v1.Attachment")
}

func init() { proto.RegisterFile("attachments.proto", fileDescriptor_1a97d0ef1337fe45) }

var fileDescriptor_1a97d0ef1337fe45 = []byte{
	// 824 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xd4, 0x56, 0xbf, 0x6f, 0xdb, 0x46,
	0x14, 0x06, 0x29, 0x57, 0x82, 0xcf, 0xb5, 0x55, 0x5d, 0x65, 0x9b, 0x66, 0x55, 0x83, 0x3d, 0x77,
	0x28, 0x54, 0x4b, 0x84, 0x6d, 0xb4, 0x06, 0x84, 0x16, 0xa8, 0x6c, 0xa3, 0x86, 0x0b, 0x17, 0x28,
	0x34, 0x14, 0x9d, 0x2a, 0x9c, 0xc9, 0x0b, 0x75, 0x88, 0xc8, 0x63, 0xc8, 0xb3, 0x84, 0xc0, 0x70,
	0x86, 0x20, 0x7f, 0x81, 0xf3, 0x0f, 0x04, 0x41, 0x86, 0x8c, 0x01, 0xb4, 0x64, 0x4d, 0x02, 0x64,
	0xc8, 0x9a, 0x2d, 0x53, 0x86, 0xfc, 0x05, 0xf1, 0x12, 0x67, 0x08, 0x02, 0xfe, 0x90, 0xc8, 0xa3,
	0x69, 0x07, 0x81, 0xa7, 0x4c, 0x36, 0xef, 0x7d, 0xef, 0xbd, 0xef, 0x7d, 0xf7, 0xf1, 0x51, 0xa0,
	0x82, 0x39, 0xc7, 0x46, 0xcf, 0x26, 0x0e, 0xf7, 0x9b, 0xae, 0xc7, 0x38, 0x83, 0xf2, 0x60, 0x4d,
	0xad, 0x59, 0x8c, 0x59, 0x7d, 0xa2, 0x63, 0x97, 0xea, 0xd8, 0x71, 0x18, 0xc7, 0x9c, 0x32, 0x27,
	0x46, 0xa8, 0xab, 0xe1, 0x1f, 0xa3, 0x61, 0x11, 0xa7, 0xe1, 0x0f, 0xb1, 0x65, 0x11, 0x4f, 0x67,
	0x6e, 0x88, 0xc8, 0x41, 0xcf, 0xc6, 0xa1, 0xf8, 0x11, 0xf8, 0x2e, 0x31, 0xa2, 0xff, 0xd1, 0x1d,
	0x09, 0x2c, 0xb6, 0x27, 0x04, 0xb6, 0x3d, 0x82, 0x39, 0xe9, 0x90, 0x1b, 0x87, 0xc4, 0xe7, 0xb0,
	0x01, 0xa6, 0x6c, 0xc2, 0xb1, 0x22, 0x69, 0xd2, 0x4f, 0x33, 0xeb, 0x4b, 0xcd, 0xc1, 0x5a, 0x53,
	0x00, 0xfc, 0x4d, 0x38, 0x36, 0x31, 0xc7, 0x9d, 0x10, 0x06, 0x5b, 0x00, 0x24, 0xa3, 0x28, 0x72,
	0x98, 0x34, 0x17, 0x24, 0x25, 0xf5, 0xb7, 0xc0, 0xdb, 0x77, 0xa3, 0xd2, 0x57, 0x8f, 0x4e, 0x47,
	0x25, 0xa9, 0x93, 0x42, 0xa3, 0xd7, 0x12, 0x50, 0xce, 0xd3, 0xf0, 0x5d, 0xe6, 0xf8, 0x04, 0xb6,
	0x04, 0x1e, 0x6a, 0x9a, 0x47, 0x84, 0x18, 0x13, 0x11, 0xca, 0x5f, 0x99, 0x14, 0xfc, 0x03, 0x00,
	0x0f, 0x73, 0xd2, 0xed, 0x53, 0x9b, 0x72, 0xa5, 0x10, 0xe6, 0xce, 0x07, 0xb9, 0x1d, 0xcc, 0xc9,
	0x7e, 0x70, 0x98, 0xdb, 0x78, 0xda, 0x1b, 0x87, 0x5b, 0xe0, 0x7d, 0x70, 0xfc, 0x30, 0x38, 0x46,
	0xff, 0x83, 0x6a, 0xd2, 0x73, 0x97, 0xf0, 0xb1, 0xca, 0x75, 0x61, 0xba, 0x85, 0xa0, 0x7e, 0x12,
	0xcd, 0x48, 0xac, 0x02, 0x99, 0x9a, 0xe1, 0x14, 0xd3, 0x42, 0x4b, 0x99, 0x9a, 0xe8, 0x95, 0x04,
	0xe6, 0x33, 0x0d, 0x62, 0xfd, 0x36, 0x85, 0x0e, 0x8b, 0x93, 0x0e, 0x5f, 0x90, 0x78, 0x66, 0xda,
	0xa5, 0x3b, 0xa4, 0x4f, 0x2e, 0x75, 0xa9, 0x00, 0xf8, 0x0c, 0x09, 0x1f, 0x08, 0x2e, 0x1c, 0x57,
	0xb9, 0xd8, 0x85, 0x22, 0xe2, 0x12, 0x21, 0x45, 0x31, 0xe4, 0x2b, 0x8a, 0x71, 0x4f, 0xb8, 0xe9,
	0x7d, 0xea, 0x4f, 0xbc, 0xf4, 0xf3, 0xf9, 0x9b, 0x4e, 0x85, 0x33, 0x4a, 0x20, 0x50, 0xbc, 0x46,
	0xfb, 0x9c, 0x78, 0x39, 0x6a, 0xc4, 0x11, 0xf8, 0x2b, 0xa8, 0x18, 0xcc, 0x76, 0x99, 0x4f, 0x39,
	0xe9, 0x7a, 0xac, 0x4f, 0xba, 0xd4, 0x0c, 0x2f, 0x53, 0x84, 0x97, 0x27, 0xa0, 0x0e, 0xeb, 0x93,
	0x3d, 0x13, 0x3d, 0x97, 0xc0, 0x42, 0x96, 0x62, 0xac, 0xe3, 0xaa, 0xc0, 0x51, 0x49, 0x38, 0x8a,
	0x2a, 0xc6, 0x24, 0x7f, 0x03, 0x33, 0xa9, 0xfd, 0xa8, 0xc8, 0x5a, 0xe1, 0x42, 0x0f, 0x3e, 0x0e,
	0xa9, 0xa4, 0xe1, 0x57, 0x37, 0x21, 0x7a, 0x22, 0x03, 0x90, 0x74, 0x82, 0x3f, 0x84, 0xee, 0x91,
	0x42, 0x01, 0x2a, 0x41, 0xc6, 0xd7, 0xf7, 0x4f, 0x47, 0x25, 0x79, 0x6f, 0x67, 0x62, 0x22, 0xf8,
	0x57, 0x9e, 0x64, 0x91, 0xc2, 0xcb, 0x41, 0xc6, 0x52, 0x90, 0x51, 0xde, 0x16, 0x04, 0xdb, 0xc9,
	0x97, 0x11, 0xee, 0x82, 0x6f, 0xa2, 0x71, 0x88, 0x99, 0x51, 0xff, 0xfb, 0xa0, 0x94, 0x12, 0x94,
	0x9a, 0x6b, 0xc7, 0x88, 0x74, 0xa5, 0x39, 0x9c, 0x3e, 0x34, 0x5b, 0x47, 0x27, 0x6d, 0xa7, 0xfe,
	0x27, 0x98, 0x6d, 0x6b, 0xc9, 0x30, 0x4d, 0xf8, 0x4b, 0x8f, 0x73, 0xd7, 0x6f, 0xe9, 0xfa, 0x70,
	0x38, 0x6c, 0xfa, 0xdc, 0x63, 0x8e, 0x65, 0xda, 0x4d, 0x83, 0xd9, 0xba, 0xc9, 0x0c, 0x3f, 0xfc,
	0xf4, 0x10, 0x87, 0x53, 0x4e, 0x89, 0xbf, 0x92, 0xe4, 0xad, 0xff, 0x08, 0xd1, 0x91, 0x86, 0xa8,
	0x89, 0x5a, 0x1a, 0xda, 0x44, 0xab, 0x1a, 0x72, 0xb0, 0x4d, 0x82, 0x87, 0x1e, 0x76, 0xdd, 0x9b,
	0x0d, 0x8b, 0x61, 0x8e, 0x8e, 0x13, 0xbf, 0xae, 0x7f, 0x28, 0x80, 0x99, 0x76, 0xea, 0x56, 0x9e,
	0x49, 0xa0, 0x18, 0x2d, 0x70, 0xf8, 0x9d, 0x78, 0x93, 0xc2, 0xe7, 0x45, 0xad, 0xe5, 0x07, 0x23,
	0x9f, 0xa0, 0x5b, 0x27, 0x6d, 0x8c, 0xba, 0x60, 0x79, 0x9f, 0x60, 0xcf, 0xd1, 0x7a, 0x6c, 0xa8,
	0x71, 0xa6, 0xd9, 0xf8, 0x3a, 0xd1, 0x70, 0x6a, 0x48, 0xf8, 0xfb, 0xa7, 0x67, 0xf4, 0x89, 0x37,
	0xa0, 0x06, 0xf1, 0xf5, 0x14, 0xc9, 0x95, 0xa8, 0xdb, 0xed, 0x97, 0x6f, 0xee, 0xca, 0x55, 0x54,
	0xd6, 0x07, 0x6b, 0x7a, 0xca, 0x58, 0x2d, 0xa9, 0x0e, 0xff, 0x03, 0x85, 0x5d, 0xc2, 0xa1, 0x22,
	0x92, 0x4c, 0x56, 0xb7, 0xba, 0x94, 0x13, 0x89, 0xb9, 0xd7, 0xc2, 0xba, 0x0b, 0xb0, 0x9a, 0xa9,
	0xab, 0x1f, 0x51, 0xf3, 0x18, 0x62, 0x50, 0x8c, 0x36, 0x4b, 0x56, 0x1e, 0x61, 0xaf, 0x65, 0xe5,
	0x11, 0x97, 0xd1, 0xb8, 0x45, 0x3d, 0xbf, 0xc5, 0xbf, 0x60, 0x2a, 0x78, 0xe9, 0x60, 0x86, 0x63,
	0x6a, 0x59, 0xa8, 0x6a, 0x5e, 0x28, 0x2e, 0xbe, 0x18, 0x16, 0xaf, 0xc0, 0xac, 0x2e, 0x6a, 0xf5,
	0xc5, 0xd9, 0xa8, 0x54, 0x7e, 0x7a, 0x36, 0x2a, 0xa5, 0xde, 0x9a, 0xad, 0x0d, 0x50, 0x33, 0x98,
	0x9d, 0xa8, 0x8f, 0x5d, 0x1a, 0x14, 0x77, 0xfb, 0x87, 0xf6, 0x01, 0x75, 0xac, 0xad, 0x6f, 0x53,
	0xc2, 0xff, 0x13, 0x1f, 0x1e, 0x14, 0xc3, 0x1f, 0x28, 0x1b, 0x1f, 0x03, 0x00, 0x00, 0xff, 0xff,
	0x3e, 0x75, 0x14, 0x5d, 0x20, 0x09, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// AttachmentsClient is the client API for Attachments service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type AttachmentsClient interface {
	// Create registers a new Attachment.
	Create(ctx context.Context, in *AttachmentCreateRequest, opts ...grpc.CallOption) (*AttachmentCreateResponse, error)
	// Get reads one Attachment by ID.
	Get(ctx context.Context, in *AttachmentGetRequest, opts ...grpc.CallOption) (*AttachmentGetResponse, error)
	// Delete removes an Attachment by ID.
	Delete(ctx context.Context, in *AttachmentDeleteRequest, opts ...grpc.CallOption) (*AttachmentDeleteResponse, error)
	// List gets a list of Attachments matching a given set of criteria.
	List(ctx context.Context, in *AttachmentListRequest, opts ...grpc.CallOption) (*AttachmentListResponse, error)
}

type attachmentsClient struct {
	cc *grpc.ClientConn
}

func NewAttachmentsClient(cc *grpc.ClientConn) AttachmentsClient {
	return &attachmentsClient{cc}
}

func (c *attachmentsClient) Create(ctx context.Context, in *AttachmentCreateRequest, opts ...grpc.CallOption) (*AttachmentCreateResponse, error) {
	out := new(AttachmentCreateResponse)
	err := c.cc.Invoke(ctx, "/v1.Attachments/Create", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *attachmentsClient) Get(ctx context.Context, in *AttachmentGetRequest, opts ...grpc.CallOption) (*AttachmentGetResponse, error) {
	out := new(AttachmentGetResponse)
	err := c.cc.Invoke(ctx, "/v1.Attachments/Get", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *attachmentsClient) Delete(ctx context.Context, in *AttachmentDeleteRequest, opts ...grpc.CallOption) (*AttachmentDeleteResponse, error) {
	out := new(AttachmentDeleteResponse)
	err := c.cc.Invoke(ctx, "/v1.Attachments/Delete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *attachmentsClient) List(ctx context.Context, in *AttachmentListRequest, opts ...grpc.CallOption) (*AttachmentListResponse, error) {
	out := new(AttachmentListResponse)
	err := c.cc.Invoke(ctx, "/v1.Attachments/List", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AttachmentsServer is the server API for Attachments service.
type AttachmentsServer interface {
	// Create registers a new Attachment.
	Create(context.Context, *AttachmentCreateRequest) (*AttachmentCreateResponse, error)
	// Get reads one Attachment by ID.
	Get(context.Context, *AttachmentGetRequest) (*AttachmentGetResponse, error)
	// Delete removes an Attachment by ID.
	Delete(context.Context, *AttachmentDeleteRequest) (*AttachmentDeleteResponse, error)
	// List gets a list of Attachments matching a given set of criteria.
	List(context.Context, *AttachmentListRequest) (*AttachmentListResponse, error)
}

// UnimplementedAttachmentsServer can be embedded to have forward compatible implementations.
type UnimplementedAttachmentsServer struct {
}

func (*UnimplementedAttachmentsServer) Create(ctx context.Context, req *AttachmentCreateRequest) (*AttachmentCreateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (*UnimplementedAttachmentsServer) Get(ctx context.Context, req *AttachmentGetRequest) (*AttachmentGetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (*UnimplementedAttachmentsServer) Delete(ctx context.Context, req *AttachmentDeleteRequest) (*AttachmentDeleteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (*UnimplementedAttachmentsServer) List(ctx context.Context, req *AttachmentListRequest) (*AttachmentListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}

func RegisterAttachmentsServer(s *grpc.Server, srv AttachmentsServer) {
	s.RegisterService(&_Attachments_serviceDesc, srv)
}

func _Attachments_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AttachmentCreateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AttachmentsServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v1.Attachments/Create",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AttachmentsServer).Create(ctx, req.(*AttachmentCreateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Attachments_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AttachmentGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AttachmentsServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v1.Attachments/Get",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AttachmentsServer).Get(ctx, req.(*AttachmentGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Attachments_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AttachmentDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AttachmentsServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v1.Attachments/Delete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AttachmentsServer).Delete(ctx, req.(*AttachmentDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Attachments_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AttachmentListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AttachmentsServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v1.Attachments/List",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AttachmentsServer).List(ctx, req.(*AttachmentListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Attachments_serviceDesc = grpc.ServiceDesc{
	ServiceName: "v1.Attachments",
	HandlerType: (*AttachmentsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _Attachments_Create_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _Attachments_Get_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _Attachments_Delete_Handler,
		},
		{
			MethodName: "List",
			Handler:    _Attachments_List_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "attachments.proto",
}
